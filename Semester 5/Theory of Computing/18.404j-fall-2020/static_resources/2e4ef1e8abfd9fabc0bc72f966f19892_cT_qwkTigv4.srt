1
00:00:00,000 --> 00:00:01,988
[SQUEAKING]

2
00:00:02,982 --> 00:00:04,473
[RUSTLING]

3
00:00:04,473 --> 00:00:05,467
[CLICKING]

4
00:00:24,890 --> 00:00:31,820
PROFESSOR: So we've been
talking about P and NP and time

5
00:00:31,820 --> 00:00:33,350
complexity classes.

6
00:00:33,350 --> 00:00:35,630
And today we're
going to shift gear.

7
00:00:35,630 --> 00:00:38,930
We're going to talk about
space complexity or memory

8
00:00:38,930 --> 00:00:44,090
complexity, as space complexity
is what complexity theorists

9
00:00:44,090 --> 00:00:48,260
usually refer to it as.

10
00:00:48,260 --> 00:00:53,810
And time and space are the
two basic most basic measures

11
00:00:53,810 --> 00:00:57,600
of complexity that we consider.

12
00:00:57,600 --> 00:01:03,470
And so today we're going to
look at the second of those two,

13
00:01:03,470 --> 00:01:04,550
the space complexity.

14
00:01:08,480 --> 00:01:13,040
A lot of this is going to
be by analogy with what

15
00:01:13,040 --> 00:01:14,420
we did for time complexity.

16
00:01:14,420 --> 00:01:16,580
We're going to define
complexity classes.

17
00:01:16,580 --> 00:01:18,740
We'll talk about
polynomial space

18
00:01:18,740 --> 00:01:21,500
and nondeterministic
polynomial space,

19
00:01:21,500 --> 00:01:25,550
see how those classes connect
up with the time complexity

20
00:01:25,550 --> 00:01:27,590
classes that we've
already defined.

21
00:01:27,590 --> 00:01:30,380
And we'll do some examples
that will be setting us up

22
00:01:30,380 --> 00:01:35,540
for our further discussion about
space complexity next week.

23
00:01:35,540 --> 00:01:37,990
So we're going to
talk about, first

24
00:01:37,990 --> 00:01:42,370
of all, what it means
for a Turing machine

25
00:01:42,370 --> 00:01:46,310
to run in a certain
amount of space.

26
00:01:46,310 --> 00:01:51,460
And that's simply going to be
counting the number of cells

27
00:01:51,460 --> 00:01:56,080
that the Turing machine
scans over on its tape

28
00:01:56,080 --> 00:01:58,000
during the course
of its computation.

29
00:01:58,000 --> 00:01:59,800
It might be reading that cell.

30
00:01:59,800 --> 00:02:01,630
It might be writing
on that cell.

31
00:02:01,630 --> 00:02:08,020
But the total number of cells
that it actually visits--

32
00:02:08,020 --> 00:02:10,810
of course, visiting the
same cell multiple times

33
00:02:10,810 --> 00:02:15,670
only counts once because
space can be reused.

34
00:02:15,670 --> 00:02:18,130
But we're going to count
the number of cells

35
00:02:18,130 --> 00:02:20,530
that the Turing machine
visits during the course

36
00:02:20,530 --> 00:02:24,520
of its computation, and
then define the space

37
00:02:24,520 --> 00:02:27,830
utilization by analogy
with what we did for time.

38
00:02:27,830 --> 00:02:30,070
So we'll say a
Turing machine runs

39
00:02:30,070 --> 00:02:31,450
in a certain amount of space--

40
00:02:31,450 --> 00:02:33,672
f of n, we'll say.

41
00:02:33,672 --> 00:02:36,130
First of all, it has to always
hold, so all of the machines

42
00:02:36,130 --> 00:02:37,600
are deciders.

43
00:02:37,600 --> 00:02:42,685
And it uses at most
that much tape--

44
00:02:45,440 --> 00:02:47,950
it visits that number of cells--

45
00:02:47,950 --> 00:02:50,980
on all inputs of length n.

46
00:02:50,980 --> 00:02:53,710
So just like we said
for time complexity,

47
00:02:53,710 --> 00:02:57,760
the machine has to
run within t of n time

48
00:02:57,760 --> 00:03:00,790
on all inputs of
length n, here it's

49
00:03:00,790 --> 00:03:04,860
going to have to use
at most f of n cells

50
00:03:04,860 --> 00:03:07,380
on all inputs of length
n in order for it

51
00:03:07,380 --> 00:03:09,480
to be running in space f of n.

52
00:03:13,070 --> 00:03:16,760
A tape cell is simply a
little square of the tape

53
00:03:16,760 --> 00:03:20,233
where you can write a symbol--

54
00:03:20,233 --> 00:03:21,900
answering a question,
that good question

55
00:03:21,900 --> 00:03:23,370
that came in from the chat.

56
00:03:23,370 --> 00:03:31,430
So I'm not sure we I have
the diagram for that.

57
00:03:31,430 --> 00:03:33,180
And each of the little
squares on the tape

58
00:03:33,180 --> 00:03:35,807
are going to be the tape cells.

59
00:03:35,807 --> 00:03:38,140
Generally, we're going to be
sticking to one-tape Turing

60
00:03:38,140 --> 00:03:38,830
machines.

61
00:03:38,830 --> 00:03:41,080
But I'll make a brief remark
about multi-tape Turing

62
00:03:41,080 --> 00:03:43,530
machines shortly.

63
00:03:43,530 --> 00:03:44,040
Better?

64
00:03:44,040 --> 00:03:48,360
Tape cells, sorry, on
all inputs of length n.

65
00:03:51,060 --> 00:03:54,720
So that's for deterministic
Turing machines.

66
00:03:54,720 --> 00:03:56,880
For nondeterministic
Turing machines,

67
00:03:56,880 --> 00:04:05,590
we will say that it also runs
in a certain amount of space.

68
00:04:05,590 --> 00:04:09,140
So for a
nondeterministic machine,

69
00:04:09,140 --> 00:04:20,200
it has to use at most that
many tape cells on each branch

70
00:04:20,200 --> 00:04:22,850
of its computation separately.

71
00:04:22,850 --> 00:04:24,820
You don't add up
the total number

72
00:04:24,820 --> 00:04:27,910
of cells used across
all of the branches,

73
00:04:27,910 --> 00:04:30,280
just like we don't add up
the total amount of time

74
00:04:30,280 --> 00:04:33,160
the machine uses across
all of its branches.

75
00:04:33,160 --> 00:04:37,990
For the machine to be running
in, say, space n squared,

76
00:04:37,990 --> 00:04:42,280
it has to be using at most
n squared cells or order n

77
00:04:42,280 --> 00:04:46,450
squared cells on each one of
its nondeterministic branches

78
00:04:46,450 --> 00:04:48,830
separately.

79
00:04:48,830 --> 00:04:52,140
There might be exponentially
many branches, but that's OK.

80
00:04:52,140 --> 00:04:56,090
But on each branch, it's going
to be using at most n squared

81
00:04:56,090 --> 00:04:58,760
or order n squared cells.

82
00:04:58,760 --> 00:05:01,730
Importantly, though,
that still the machine

83
00:05:01,730 --> 00:05:03,260
has to be a decider.

84
00:05:03,260 --> 00:05:07,010
It's not enough to be
looping forever and using

85
00:05:07,010 --> 00:05:09,590
a small amount of space.

86
00:05:09,590 --> 00:05:11,480
It could do that,
but that's not going

87
00:05:11,480 --> 00:05:16,010
to count toward the machine
contributing to its space

88
00:05:16,010 --> 00:05:17,730
complexity of that language.

89
00:05:17,730 --> 00:05:21,350
So for the machine to be running
in a certain amount of space,

90
00:05:21,350 --> 00:05:25,610
we say that the machine
holds on all of its branches.

91
00:05:25,610 --> 00:05:30,590
And each one of its branches
uses at most that much space.

92
00:05:36,520 --> 00:05:38,760
I can see lots of typos here.

93
00:05:38,760 --> 00:05:40,394
Thank you.

94
00:05:40,394 --> 00:05:44,430
Why did I mess
this all up today?

95
00:05:44,430 --> 00:05:54,110
So nondeterministic--
good, thank you.

96
00:05:59,370 --> 00:06:03,660
All right, so we're going to
define the space complexity

97
00:06:03,660 --> 00:06:06,430
classes analogous to this
time complexity classes.

98
00:06:06,430 --> 00:06:13,100
So these are languages that
you can do with machines that

99
00:06:13,100 --> 00:06:15,850
run within that space bound.

100
00:06:15,850 --> 00:06:21,060
So space f of n-- you can
think of space n squared--

101
00:06:21,060 --> 00:06:26,830
is all of the languages that a
deterministic one-tape Turing

102
00:06:26,830 --> 00:06:30,700
machine can do within--

103
00:06:30,700 --> 00:06:35,260
can decide within-- by using
at most n squared tape cells,

104
00:06:35,260 --> 00:06:36,790
order n squared tape cells.

105
00:06:36,790 --> 00:06:40,990
Similarly, the nondeterministic
space complexity class

106
00:06:40,990 --> 00:06:45,850
are all of the languages that
a nondeterministic one-tape

107
00:06:45,850 --> 00:06:48,190
Turing machine can
decide, running

108
00:06:48,190 --> 00:06:49,375
within that amount of space.

109
00:06:53,440 --> 00:06:58,030
And lastly, we have
polynomial space.

110
00:06:58,030 --> 00:07:01,120
So that's the union over
all polynomial space bounds

111
00:07:01,120 --> 00:07:04,480
of the space complexity class,
and nondeterministic polynomial

112
00:07:04,480 --> 00:07:05,590
space--

113
00:07:05,590 --> 00:07:09,310
the same for all of the
nondeterministic polynomial

114
00:07:09,310 --> 00:07:12,260
space classes.

115
00:07:12,260 --> 00:07:18,970
So I think I do have
a check-in on this

116
00:07:18,970 --> 00:07:22,495
which talks about
multi-tape Turing machines.

117
00:07:25,190 --> 00:07:27,850
So we can define
space complexity

118
00:07:27,850 --> 00:07:30,520
for multi-tape
Turing machines, just

119
00:07:30,520 --> 00:07:32,860
as we did for one-tape
Turing machines,

120
00:07:32,860 --> 00:07:36,580
and then define the associated
space complexity classes,

121
00:07:36,580 --> 00:07:40,580
and then define
the class P space.

122
00:07:40,580 --> 00:07:44,530
But that would be for
multi-tape Turing machines.

123
00:07:44,530 --> 00:07:49,690
Now for time, remember
that the class

124
00:07:49,690 --> 00:07:52,600
P that you would get for
multi-tape Turing machines is

125
00:07:52,600 --> 00:07:56,230
exactly the same as the class P
that we got for one-tape Turing

126
00:07:56,230 --> 00:07:57,670
machines.

127
00:07:57,670 --> 00:08:02,565
That was part of the
nice quality of the class

128
00:08:02,565 --> 00:08:04,530
P. It's robust in that
sense, and natural.

129
00:08:04,530 --> 00:08:06,420
So how about for PSPACE?

130
00:08:06,420 --> 00:08:07,170
What do you think?

131
00:08:07,170 --> 00:08:10,030
Do we get the same class?

132
00:08:10,030 --> 00:08:10,530
No?

133
00:08:10,530 --> 00:08:11,430
Maybe?

134
00:08:11,430 --> 00:08:15,960
Or yes, because we can convert
a multi-tape Turing machine

135
00:08:15,960 --> 00:08:18,090
to a single-tape
Turing machine, by only

136
00:08:18,090 --> 00:08:21,240
squaring the amount of space?

137
00:08:21,240 --> 00:08:23,790
That was what happened
with time, as you remember.

138
00:08:23,790 --> 00:08:25,350
Or maybe we can do even better.

139
00:08:25,350 --> 00:08:28,050
Converting a multi-tape Turing
machine to single-tape only

140
00:08:28,050 --> 00:08:31,590
increases it by less-- by,
say, a constant factor.

141
00:08:31,590 --> 00:08:33,630
Here, remember,
this is how we're

142
00:08:33,630 --> 00:08:36,390
defining space complexity for
multi-tape Turing machines.

143
00:08:36,390 --> 00:08:40,199
We're taking the sum of all the
cells used on all of the tapes.

144
00:08:43,730 --> 00:08:50,420
All right, so let's launch that
poll and see what you think.

145
00:08:50,420 --> 00:08:52,735
Hopefully, this is not too hard.

146
00:08:55,870 --> 00:08:58,090
Yeah, I think most of you
have got the idea, though.

147
00:08:58,090 --> 00:08:59,290
Some of you are--

148
00:08:59,290 --> 00:09:03,310
I worry sometimes about some
of the answers that I get.

149
00:09:03,310 --> 00:09:06,790
I don't know if you're
serious, or you're really

150
00:09:06,790 --> 00:09:10,090
badly confused.

151
00:09:10,090 --> 00:09:13,640
But anyway, let's wrap this up--

152
00:09:13,640 --> 00:09:17,820
another 10 seconds or so.

153
00:09:21,695 --> 00:09:22,195
Last call.

154
00:09:25,267 --> 00:09:26,100
I'm going to end it.

155
00:09:30,330 --> 00:09:37,680
Yeah, I mean, I think answer
B is a reasonable answer.

156
00:09:37,680 --> 00:09:41,790
In fact, answer C is
the correct answer.

157
00:09:41,790 --> 00:09:46,080
If you just look at the same
simulation from multi-tape

158
00:09:46,080 --> 00:09:51,660
to single-tape and how much
space overhead that simulation

159
00:09:51,660 --> 00:09:54,660
introduces, it's only linear.

160
00:09:54,660 --> 00:09:56,670
You're basically just
taking all of the tapes

161
00:09:56,670 --> 00:09:58,740
of the multi-tape
machine and writing them

162
00:09:58,740 --> 00:10:02,340
down next to one another,
obviously ignoring

163
00:10:02,340 --> 00:10:04,380
all the infinitely many blanks.

164
00:10:04,380 --> 00:10:06,608
We're just taking the
active portion of the tapes,

165
00:10:06,608 --> 00:10:08,150
writing them down
next to each other.

166
00:10:08,150 --> 00:10:10,410
So the total amount
used is just going

167
00:10:10,410 --> 00:10:13,440
to be the sum on the
single-tape of what

168
00:10:13,440 --> 00:10:18,180
was used on each of the
individual multi-tapes

169
00:10:18,180 --> 00:10:19,890
in the original machine.

170
00:10:19,890 --> 00:10:24,240
So there is just a
linear cost overhead

171
00:10:24,240 --> 00:10:26,190
by converting from
multi-tape to single-tape

172
00:10:26,190 --> 00:10:28,890
when you're looking at space,
the amount of memory that's

173
00:10:28,890 --> 00:10:30,880
used.

174
00:10:30,880 --> 00:10:33,640
For time, remember there
was some additional overhead

175
00:10:33,640 --> 00:10:38,980
because we had to be updating
where the virtual heads were.

176
00:10:38,980 --> 00:10:44,200
And that cost extra time to
move our single head around

177
00:10:44,200 --> 00:10:45,140
to do that.

178
00:10:45,140 --> 00:10:48,400
But for space, the amount
of time that's introduced

179
00:10:48,400 --> 00:10:49,518
is irrelevant.

180
00:10:49,518 --> 00:10:51,310
We're only looking at
the amount of memory.

181
00:10:51,310 --> 00:10:52,495
And so that's a--

182
00:10:56,041 --> 00:10:59,500
the overhead on
that is very low.

183
00:10:59,500 --> 00:11:03,420
I do worry about the folks who
are answering A, for example,

184
00:11:03,420 --> 00:11:04,420
for this question.

185
00:11:04,420 --> 00:11:08,860
You should be rethinking
what's really going on here.

186
00:11:14,570 --> 00:11:23,030
Now let us move on here
from that to our next slide

187
00:11:23,030 --> 00:11:29,795
and compare the time and
space complexity classes.

188
00:11:29,795 --> 00:11:34,200
Time and space complexity-- how
do they relate to one another?

189
00:11:34,200 --> 00:11:37,370
And so first of all,
we're going to point out--

190
00:11:40,190 --> 00:11:44,960
let's start out--
here, t of n is

191
00:11:44,960 --> 00:11:46,490
going to be
representing some bound,

192
00:11:46,490 --> 00:11:48,830
either on the time or
the amount of space.

193
00:11:48,830 --> 00:11:52,130
And generally, at least
up until this point,

194
00:11:52,130 --> 00:11:54,680
and mostly going
forward, though there's

195
00:11:54,680 --> 00:11:58,080
going to be one variation
on that a little later,

196
00:11:58,080 --> 00:12:02,030
but we're going to be
focusing on bounds which

197
00:12:02,030 --> 00:12:05,570
are at least big enough
to either read the input

198
00:12:05,570 --> 00:12:07,230
or at least hold the input.

199
00:12:07,230 --> 00:12:13,530
So that's why we refer to
t of n being at least n.

200
00:12:13,530 --> 00:12:19,080
So now if we look at the time
complexity class t of n--

201
00:12:19,080 --> 00:12:21,660
think of-- t of n
typically would be, say,

202
00:12:21,660 --> 00:12:24,650
n squared, maybe.

203
00:12:24,650 --> 00:12:27,110
And the things that
you can do in n

204
00:12:27,110 --> 00:12:32,420
squared time I claim you can
also do in n squared space.

205
00:12:35,240 --> 00:12:40,010
And basically, it's just
using the very same machine.

206
00:12:40,010 --> 00:12:43,130
Suppose you have a machine
that runs in n squared time.

207
00:12:43,130 --> 00:12:45,740
How could it possibly
use, say, n squared--

208
00:12:45,740 --> 00:12:49,610
n cubed-- space, if it's
running only in n squared time?

209
00:12:49,610 --> 00:12:53,490
Even if it tries to use as
much tape as it possibly could,

210
00:12:53,490 --> 00:12:56,300
as many tape cells
as it possibly could,

211
00:12:56,300 --> 00:13:00,290
and sending its
head cruising out

212
00:13:00,290 --> 00:13:03,680
into the blank portion of the
tape, chewing up as much--

213
00:13:03,680 --> 00:13:06,140
as many tape cells
as it possibly can--

214
00:13:06,140 --> 00:13:08,300
in n squared time,
it's only going

215
00:13:08,300 --> 00:13:10,910
to be able to use
n squared space.

216
00:13:10,910 --> 00:13:14,780
So the very same machine
that runs in t of n time

217
00:13:14,780 --> 00:13:17,610
is also going to
run in t of n space.

218
00:13:17,610 --> 00:13:23,420
So this containment
here follows really

219
00:13:23,420 --> 00:13:27,840
without doing any work at all.

220
00:13:27,840 --> 00:13:33,380
So just restating that here, a
Turing machine that runs in t

221
00:13:33,380 --> 00:13:37,670
of n steps cannot use more
than t of n tape cells.

222
00:13:37,670 --> 00:13:39,270
So right now,
we're focusing on--

223
00:13:39,270 --> 00:13:41,630
we could prove some
analogous statements

224
00:13:41,630 --> 00:13:45,170
about nondeterministic
complexity,

225
00:13:45,170 --> 00:13:49,310
but let's focus here on the
deterministic complexity.

226
00:13:49,310 --> 00:13:51,560
Now let's look at going
the other direction.

227
00:13:51,560 --> 00:13:58,400
Suppose we have a Turing machine
that uses t of n space now.

228
00:13:58,400 --> 00:14:03,150
Does that immediately imply
it's using only t of n time?

229
00:14:03,150 --> 00:14:07,680
And that's not so clear and,
in fact, probably not true,

230
00:14:07,680 --> 00:14:12,870
because space appears to be
much more powerful than time.

231
00:14:12,870 --> 00:14:14,490
And within a certain
amount of space,

232
00:14:14,490 --> 00:14:18,700
you can run for much longer
than that same amount of time.

233
00:14:18,700 --> 00:14:22,400
So how long could you run?

234
00:14:22,400 --> 00:14:28,510
So what you can show is that if
you're running within a certain

235
00:14:28,510 --> 00:14:30,760
amount of space-- t of
n space, let's say--

236
00:14:30,760 --> 00:14:33,680
n squared space, for example.

237
00:14:33,680 --> 00:14:35,980
The amount of time
you could use is

238
00:14:35,980 --> 00:14:40,025
going to be exponential in n
squared, a 2 to the order n

239
00:14:40,025 --> 00:14:40,525
squared.

240
00:14:43,060 --> 00:14:48,880
Sometimes we also write that
as the union of c to the n

241
00:14:48,880 --> 00:14:53,050
squared by pulling down
that constant here.

242
00:14:53,050 --> 00:14:55,240
Well, it's also
just to understand

243
00:14:55,240 --> 00:14:58,030
what we mean by order t
of n up in the exponent.

244
00:14:58,030 --> 00:15:02,432
It means the union over c
to the t of n for all c.

245
00:15:02,432 --> 00:15:04,390
Either of these are just
completely equivalent,

246
00:15:04,390 --> 00:15:06,790
so whichever one you're
more comfortable with.

247
00:15:06,790 --> 00:15:08,750
But why is this
going to be true?

248
00:15:08,750 --> 00:15:17,410
Why does a Turing machine that
runs in, say, n squared space,

249
00:15:17,410 --> 00:15:26,540
use at most 2 to the
order n squared time?

250
00:15:26,540 --> 00:15:28,790
And that's because
if you look at how

251
00:15:28,790 --> 00:15:33,020
many possible configurations
the machine can have,

252
00:15:33,020 --> 00:15:37,220
remember that a
configuration is essentially

253
00:15:37,220 --> 00:15:38,840
the contents of the tape.

254
00:15:38,840 --> 00:15:41,180
There's also the head
position and the state.

255
00:15:41,180 --> 00:15:47,390
But the dominant aspect of
a configuration is the tape.

256
00:15:47,390 --> 00:15:51,820
And so how many different
tape contents can you have?

257
00:15:51,820 --> 00:15:54,910
Well, it's going to be
exponential in the length

258
00:15:54,910 --> 00:15:59,110
of that tape because each
cell can have some fixed

259
00:15:59,110 --> 00:16:02,150
number of symbols in it.

260
00:16:02,150 --> 00:16:05,480
If a machine repeats
a configuration,

261
00:16:05,480 --> 00:16:07,130
it's going to go
forever, which we're

262
00:16:07,130 --> 00:16:12,410
forbidding in these
machines, because they're all

263
00:16:12,410 --> 00:16:13,730
going to be deciders.

264
00:16:13,730 --> 00:16:19,290
So they can only run
for an amount of time

265
00:16:19,290 --> 00:16:21,680
which is bounded by the
number of configurations

266
00:16:21,680 --> 00:16:23,340
that the machine can have.

267
00:16:23,340 --> 00:16:24,635
And so the machine can have--

268
00:16:27,590 --> 00:16:32,180
if it's running in t of
n space, then the amount

269
00:16:32,180 --> 00:16:34,640
of time that it
could be running is

270
00:16:34,640 --> 00:16:38,180
going to be at most some
constant to the t of n or 2

271
00:16:38,180 --> 00:16:42,210
to the order of t of n,
saying the same thing,

272
00:16:42,210 --> 00:16:44,148
unless it's going to
repeat a configuration

273
00:16:44,148 --> 00:16:44,940
and end up looping.

274
00:16:47,780 --> 00:16:51,050
So these are the two
fundamental connections

275
00:16:51,050 --> 00:16:52,550
between time and space.

276
00:16:52,550 --> 00:16:55,520
Time is contained within
the same amount of space.

277
00:16:55,520 --> 00:16:59,240
Space is contained within that
amount of time exponentiated.

278
00:17:04,310 --> 00:17:08,060
So one corollary of
that is that the class P

279
00:17:08,060 --> 00:17:09,270
is contained within PSPACE.

280
00:17:13,069 --> 00:17:16,089
Similarly, NP is going to
be contained within NPSPACE

281
00:17:16,089 --> 00:17:17,230
for the very same reason.

282
00:17:22,700 --> 00:17:28,089
Is this understandable?

283
00:17:28,089 --> 00:17:31,180
This is a good place or
a moment to add one more

284
00:17:31,180 --> 00:17:34,450
line to tell you about.

285
00:17:34,450 --> 00:17:39,410
But leading into the next slide,
we're-- so if you understand

286
00:17:39,410 --> 00:17:45,731
the definitions of what
we've done so far, all of--

287
00:17:45,731 --> 00:17:48,290
this is a fairly
straightforward theorem,

288
00:17:48,290 --> 00:17:51,670
and the corollary is immediate.

289
00:17:51,670 --> 00:17:55,590
So anything that you
can do in n squared time

290
00:17:55,590 --> 00:17:56,980
you can do in n
squared in space.

291
00:17:56,980 --> 00:17:59,370
And so anything you can
do in polynomial time

292
00:17:59,370 --> 00:18:02,110
you can also do in
polynomial space.

293
00:18:02,110 --> 00:18:04,930
Yeah, c-- somebody's
asking me, what is the c?

294
00:18:04,930 --> 00:18:10,628
c is essentially going to be
the size of the tape alphabet

295
00:18:10,628 --> 00:18:12,670
because that's going to
govern how many different

296
00:18:12,670 --> 00:18:13,670
configurations you have.

297
00:18:13,670 --> 00:18:19,810
There's a slight extra
factor for the tape--

298
00:18:19,810 --> 00:18:23,740
the head location
and also the state.

299
00:18:23,740 --> 00:18:28,520
But the main thing is going to
be the number of tape symbols

300
00:18:28,520 --> 00:18:29,810
and the length of the tape.

301
00:18:32,360 --> 00:18:34,460
But what's going to
come next is we're

302
00:18:34,460 --> 00:18:38,960
going to prove something more
powerful than this corollary

303
00:18:38,960 --> 00:18:41,930
that P is contained in
PSPACE, because not only is P

304
00:18:41,930 --> 00:18:45,187
contained in PSPACE, but NP
is also contained in PSPACE.

305
00:18:45,187 --> 00:18:47,270
And for that, we're going
to have to do more work.

306
00:18:54,730 --> 00:18:57,060
So somebody's asking me
about the number of states.

307
00:18:57,060 --> 00:19:00,360
The number of states
is going to be--

308
00:19:00,360 --> 00:19:04,740
is fixed depending
on the machine only.

309
00:19:04,740 --> 00:19:10,920
So it doesn't depend upon n.

310
00:19:10,920 --> 00:19:17,430
So it could at most affect
the number of configurations

311
00:19:17,430 --> 00:19:19,050
by a constant factor.

312
00:19:19,050 --> 00:19:20,550
And those constant
factors are going

313
00:19:20,550 --> 00:19:25,750
to be absorbed within the
definitions of these complexity

314
00:19:25,750 --> 00:19:34,085
classes because that's how
we define them to be ignoring

315
00:19:34,085 --> 00:19:34,960
the constant factors.

316
00:19:40,930 --> 00:19:43,450
Why don't we just take a--

317
00:19:43,450 --> 00:19:46,150
this may be a good place
to pause for a second

318
00:19:46,150 --> 00:19:53,090
and see if there's any
questions, because I

319
00:19:53,090 --> 00:19:56,030
think for some of you, this
may be straightforward.

320
00:19:56,030 --> 00:19:59,630
But I think it's less
common to be measuring--

321
00:19:59,630 --> 00:20:04,740
thinking about the amount of
memory as a complexity measure.

322
00:20:04,740 --> 00:20:06,560
So this is perhaps a
little less familiar.

323
00:20:06,560 --> 00:20:10,610
Some of you have seen measuring
time in other classes,

324
00:20:10,610 --> 00:20:13,280
but measuring the
amount of space

325
00:20:13,280 --> 00:20:16,220
that the algorithm uses probably
is a little less familiar.

326
00:20:16,220 --> 00:20:19,550
And maybe it's worth spending
a moment or two answering

327
00:20:19,550 --> 00:20:20,480
questions about that.

328
00:20:28,310 --> 00:20:30,810
So I'm not sure I understand
the question that just came in,

329
00:20:30,810 --> 00:20:32,800
but I'll read it out there.

330
00:20:32,800 --> 00:20:35,310
Is it possible that a Turing
machine can loop forever?

331
00:20:35,310 --> 00:20:36,270
Absolutely.

332
00:20:36,270 --> 00:20:38,280
But a Turing machine
that loops forever

333
00:20:38,280 --> 00:20:41,910
does not count as one that
runs within the space bound.

334
00:20:41,910 --> 00:20:44,400
To run within the space
bound, the machine

335
00:20:44,400 --> 00:20:45,630
must halt on every input.

336
00:20:45,630 --> 00:20:46,620
It has to be a decider.

337
00:20:46,620 --> 00:20:49,080
We're only considering
deciders here.

338
00:20:49,080 --> 00:20:51,330
So is it possible a Turing
machine could loop forever?

339
00:20:51,330 --> 00:20:51,900
Yes.

340
00:20:51,900 --> 00:20:53,483
Isn't the Turing
machine we're talking

341
00:20:53,483 --> 00:20:55,725
about a member of space,
and thus a decider?

342
00:20:59,860 --> 00:21:01,960
Not totally sure I
understand the question.

343
00:21:01,960 --> 00:21:11,710
But if a Turing machine is
not halting on all inputs,

344
00:21:11,710 --> 00:21:12,820
it's not a decider.

345
00:21:12,820 --> 00:21:14,724
That's our definition.

346
00:21:18,182 --> 00:21:18,788
Are we good?

347
00:21:18,788 --> 00:21:20,580
We're not getting very
many questions here.

348
00:21:20,580 --> 00:21:22,310
So I'm assuming
you're all with me

349
00:21:22,310 --> 00:21:28,040
or so lost you don't even know
what to ask, which is not good.

350
00:21:28,040 --> 00:21:29,450
So be bold.

351
00:21:29,450 --> 00:21:32,420
If you're confused, throw
a question out there,

352
00:21:32,420 --> 00:21:34,970
because I don't want to
race through this lecture,

353
00:21:34,970 --> 00:21:38,810
since it's maybe a little
less familiar to some of you.

354
00:21:38,810 --> 00:21:41,360
So let's move on.

355
00:21:41,360 --> 00:21:45,980
As promised, I'm going to show
you now that NP, not only P,

356
00:21:45,980 --> 00:21:50,270
as happens immediately,
but NP is contained

357
00:21:50,270 --> 00:21:51,950
as a subset of a PSPACE.

358
00:21:54,540 --> 00:21:56,760
So that is--

359
00:21:56,760 --> 00:21:58,200
I did get a question.

360
00:21:58,200 --> 00:22:01,020
I moved on before I
answered this question.

361
00:22:01,020 --> 00:22:03,030
Can I explain part two
of the proof again?

362
00:22:03,030 --> 00:22:03,900
Part two?

363
00:22:03,900 --> 00:22:05,010
OK, let's just do it.

364
00:22:08,410 --> 00:22:10,840
If something runs in a
certain amount of space,

365
00:22:10,840 --> 00:22:13,630
you have to just think about how
many different configurations

366
00:22:13,630 --> 00:22:16,030
the machine can have within
that amount of space.

367
00:22:16,030 --> 00:22:21,010
Remember the configurations that
we defined way back at LBAs?

368
00:22:21,010 --> 00:22:22,930
So the number of
configurations of the machine

369
00:22:22,930 --> 00:22:27,070
can have depends on how
much space it's allocated.

370
00:22:27,070 --> 00:22:30,430
Like the LBAs-- they had a
fixed number of configurations,

371
00:22:30,430 --> 00:22:33,610
and we gave a
calculation for that,

372
00:22:33,610 --> 00:22:35,650
which is basically
an exponential

373
00:22:35,650 --> 00:22:36,850
in the amount of space.

374
00:22:36,850 --> 00:22:39,830
That's how many configurations
the machine can have.

375
00:22:39,830 --> 00:22:44,860
So if the machine is not
looping, if it's a decider,

376
00:22:44,860 --> 00:22:46,810
it can never repeat
a configuration.

377
00:22:46,810 --> 00:22:49,820
And that's going to tell us how
long the machine can possibly

378
00:22:49,820 --> 00:22:50,320
run for.

379
00:22:54,264 --> 00:22:55,860
It's important to understand.

380
00:22:55,860 --> 00:22:57,480
I'm not sure if
I knew how to say

381
00:22:57,480 --> 00:23:02,640
that in any way that different
from what I said before.

382
00:23:02,640 --> 00:23:07,420
OK, getting back now to proving
that NP is a subset of PSPACE.

383
00:23:07,420 --> 00:23:09,960
So now we're going to have
to do something that's

384
00:23:09,960 --> 00:23:13,740
in a way different from what
we did on the previous slide,

385
00:23:13,740 --> 00:23:17,970
because now it's not
going to be enough to work

386
00:23:17,970 --> 00:23:19,320
with the same machine.

387
00:23:19,320 --> 00:23:21,360
Before when we were
converting, we're

388
00:23:21,360 --> 00:23:24,270
showing that a certain
amount of time, time class,

389
00:23:24,270 --> 00:23:25,890
is contained within
a space class

390
00:23:25,890 --> 00:23:27,750
by virtue of the
very same machine--

391
00:23:27,750 --> 00:23:30,330
by just showing
that if it's running

392
00:23:30,330 --> 00:23:32,010
within a certain
amount of time, then it

393
00:23:32,010 --> 00:23:37,110
has to be running within
that same amount of space.

394
00:23:37,110 --> 00:23:38,982
Or in terms of the
space, it was in the--

395
00:23:38,982 --> 00:23:40,440
given a certain
amount of space, it

396
00:23:40,440 --> 00:23:42,898
has to be running that same
machine within a certain amount

397
00:23:42,898 --> 00:23:45,230
of time.

398
00:23:45,230 --> 00:23:47,750
Here we're going to--
mixing non-determinism

399
00:23:47,750 --> 00:23:48,570
and determinism.

400
00:23:48,570 --> 00:23:52,160
So we're going to have to take
a machine that's an NP type

401
00:23:52,160 --> 00:23:55,400
machine, a nondeterministic
polynomial time machine,

402
00:23:55,400 --> 00:23:57,860
and convert it into a
deterministic machine that

403
00:23:57,860 --> 00:24:00,700
doesn't use a
whole lot of space.

404
00:24:00,700 --> 00:24:06,190
So there's a difference in
the character of this theorem

405
00:24:06,190 --> 00:24:10,370
because we have to
introduce a new machine.

406
00:24:10,370 --> 00:24:14,865
And the way we're going
to prove that, I'm

407
00:24:14,865 --> 00:24:16,740
going to take advantage
of some of the things

408
00:24:16,740 --> 00:24:20,370
we've already shown
to prove this.

409
00:24:20,370 --> 00:24:23,130
One could also prove it a
little bit more directly.

410
00:24:23,130 --> 00:24:26,650
And maybe it's worth making
sure you understand both proofs.

411
00:24:26,650 --> 00:24:30,180
So the first thing
I'm going to observe

412
00:24:30,180 --> 00:24:35,070
is that SAT, our
NP-complete language,

413
00:24:35,070 --> 00:24:39,210
the satisfiability language,
itself is a member of PSPACE.

414
00:24:42,470 --> 00:24:48,650
And the reason for that is
when you're given a formula,

415
00:24:48,650 --> 00:24:56,170
and now you want to test if
that formula is satisfiable,

416
00:24:56,170 --> 00:24:59,710
one way to do it, the
most obvious way to do it,

417
00:24:59,710 --> 00:25:06,280
is try all assignments one
by one and see if any of them

418
00:25:06,280 --> 00:25:07,375
satisfy the formula.

419
00:25:09,880 --> 00:25:12,100
Now that's going to
take a lot of time.

420
00:25:12,100 --> 00:25:14,770
But how much space does it use?

421
00:25:14,770 --> 00:25:18,910
I have in mind reusing
the space every time

422
00:25:18,910 --> 00:25:21,490
we try the next assignment.

423
00:25:21,490 --> 00:25:24,070
Think of going through all
of the assignments the way

424
00:25:24,070 --> 00:25:26,230
an odometer would work--

425
00:25:26,230 --> 00:25:29,050
just trying every
possible assignment,

426
00:25:29,050 --> 00:25:30,880
but reusing the
space where you're

427
00:25:30,880 --> 00:25:35,220
going to write that
assignment down,

428
00:25:35,220 --> 00:25:41,040
incrementing it like a number
written in binary, if you wish.

429
00:25:41,040 --> 00:25:43,290
Going through all the possible
assignments, every time

430
00:25:43,290 --> 00:25:46,380
you get in the next assignment,
you plug it into the formula

431
00:25:46,380 --> 00:25:48,080
and see if the
formula's satisfied.

432
00:25:48,080 --> 00:25:49,830
If it is, then you can
accept immediately.

433
00:25:49,830 --> 00:25:51,990
If not, you go on to
the next assignment.

434
00:25:51,990 --> 00:25:54,450
And only when you've gone
through all the assignments

435
00:25:54,450 --> 00:25:58,270
in that way, and none of them
have satisfied the formula,

436
00:25:58,270 --> 00:25:59,200
then you can reject.

437
00:25:59,200 --> 00:26:01,218
So how much space does that use?

438
00:26:01,218 --> 00:26:02,760
That doesn't use a
whole lot of space

439
00:26:02,760 --> 00:26:06,780
because you're reusing
the space to write down

440
00:26:06,780 --> 00:26:10,470
one assignment after the next.

441
00:26:10,470 --> 00:26:13,380
It's only going to be using
an amount of space which

442
00:26:13,380 --> 00:26:15,930
is big enough to hold an
assignment, which is basically

443
00:26:15,930 --> 00:26:18,570
linear, because it's the size
of the number of variables

444
00:26:18,570 --> 00:26:19,450
of the formula.

445
00:26:19,450 --> 00:26:24,150
So that's going to be a linear
amount of space to solve

446
00:26:24,150 --> 00:26:25,750
the satisfiability problem.

447
00:26:25,750 --> 00:26:27,240
And so the
satisfiability problem

448
00:26:27,240 --> 00:26:31,680
is certainly in PSPACE--

449
00:26:31,680 --> 00:26:34,310
step one.

450
00:26:34,310 --> 00:26:38,230
Step two is we're going
to take advantage of what

451
00:26:38,230 --> 00:26:40,870
we know about reducibility.

452
00:26:40,870 --> 00:26:45,610
So if A is polynomial
time reducible to B,

453
00:26:45,610 --> 00:26:47,930
we've already commented--
we didn't say this exactly

454
00:26:47,930 --> 00:26:48,430
in this way.

455
00:26:48,430 --> 00:26:51,670
But it's still going to
follow that anything you

456
00:26:51,670 --> 00:26:53,380
can do in a certain
amount of time,

457
00:26:53,380 --> 00:26:55,420
you can also do in
that amount of space,

458
00:26:55,420 --> 00:26:59,275
because it's the
very same machine--

459
00:26:59,275 --> 00:27:01,610
can't use any more space
than the amount of time

460
00:27:01,610 --> 00:27:04,530
it was allocated.

461
00:27:04,530 --> 00:27:07,410
So if A is polynomial
time reducible to B,

462
00:27:07,410 --> 00:27:10,230
it's also going to be
reducible in polynomial space.

463
00:27:10,230 --> 00:27:16,030
A polynomial space machine
could do the reduction.

464
00:27:16,030 --> 00:27:19,860
So that means if A is
polynomial time reducible to B,

465
00:27:19,860 --> 00:27:21,750
and B is in
polynomial space, then

466
00:27:21,750 --> 00:27:25,680
A is also in polynomial space.

467
00:27:25,680 --> 00:27:29,760
But we know, because
satisfiability is NP-complete,

468
00:27:29,760 --> 00:27:34,070
that every language of
NP is reducible to SAT.

469
00:27:34,070 --> 00:27:37,200
So put SAT in place
of B. Every NP

470
00:27:37,200 --> 00:27:40,500
language is polynomial
time-reducible to SAT.

471
00:27:40,500 --> 00:27:43,380
And we now know that
SAT is in PSPACE.

472
00:27:43,380 --> 00:27:46,140
So therefore, every
language in NP

473
00:27:46,140 --> 00:27:48,480
is in PSPACE because
they're all polynomial time

474
00:27:48,480 --> 00:27:49,350
reducible to SAT.

475
00:27:52,640 --> 00:27:55,850
So just by using some
of the technology

476
00:27:55,850 --> 00:27:59,600
we've developed, namely
the notion of completeness

477
00:27:59,600 --> 00:28:04,160
shows some of its power, that if
you want to conclude something

478
00:28:04,160 --> 00:28:08,030
about an entire class, an
entire complexity class,

479
00:28:08,030 --> 00:28:10,580
if you have a complete problem
for that complexity class,

480
00:28:10,580 --> 00:28:13,730
often it's enough just to work
with the complete problem.

481
00:28:13,730 --> 00:28:16,940
And then everything else by
virtue of the reducibility,

482
00:28:16,940 --> 00:28:19,700
is going to inherit
the same property.

483
00:28:19,700 --> 00:28:21,980
Doesn't work in all cases,
but in many of the cases,

484
00:28:21,980 --> 00:28:26,060
as long as the reducibility
can be computed

485
00:28:26,060 --> 00:28:31,950
by the type of procedure
you're working with,

486
00:28:31,950 --> 00:28:35,340
then you can-- then it follows.

487
00:28:35,340 --> 00:28:37,200
You could also prove
this more directly.

488
00:28:37,200 --> 00:28:38,910
I think it's in some
ways a little clumsy

489
00:28:38,910 --> 00:28:41,970
or a little bit less elegant.

490
00:28:41,970 --> 00:28:46,740
But you can say, well,
let me just take my--

491
00:28:46,740 --> 00:28:48,840
take a language that's in NP.

492
00:28:48,840 --> 00:28:52,500
It has a nondeterministic
polynomial time algorithm.

493
00:28:52,500 --> 00:28:56,940
And then give a deterministic
polynomial space algorithm--

494
00:28:56,940 --> 00:29:00,750
simulates that NP algorithm
just by going through all

495
00:29:00,750 --> 00:29:02,880
the different branches,
but making sure

496
00:29:02,880 --> 00:29:05,100
that going through all
those different branches,

497
00:29:05,100 --> 00:29:07,753
you're reusing the space and
not using new space every time

498
00:29:07,753 --> 00:29:09,420
you're going through
a different branch.

499
00:29:09,420 --> 00:29:12,240
And you can arrange things
if you're just a little bit

500
00:29:12,240 --> 00:29:13,710
careful to do it that way.

501
00:29:13,710 --> 00:29:15,870
So you could give
a direct simulation

502
00:29:15,870 --> 00:29:19,810
in polynomial space of
any NP Turing machine.

503
00:29:19,810 --> 00:29:22,040
So I mean, that's also
completely satisfactory.

504
00:29:22,040 --> 00:29:23,790
But I think this is a
little more elegant.

505
00:29:26,960 --> 00:29:29,630
This furthermore
is going to allow

506
00:29:29,630 --> 00:29:35,700
us to conclude some additional
languages are in PSPACE.

507
00:29:35,700 --> 00:29:38,820
Let's define a class we have not
yet seen, though maybe you've

508
00:29:38,820 --> 00:29:39,690
seen this--

509
00:29:39,690 --> 00:29:45,810
I think we've talked about
this notion of co before.

510
00:29:45,810 --> 00:29:50,110
I think we talked about
co-Turing-recognizable.

511
00:29:55,110 --> 00:29:57,930
Those are the class of
languages whose complements

512
00:29:57,930 --> 00:30:01,290
are Turing-recognizable,
and the same for co and P.

513
00:30:01,290 --> 00:30:04,890
This is the class of languages
whose complements are in NP.

514
00:30:08,280 --> 00:30:10,920
If you take the complement of
every language that's in NP,

515
00:30:10,920 --> 00:30:12,420
and now you got
all the languages

516
00:30:12,420 --> 00:30:14,580
that are in this class coNP.

517
00:30:14,580 --> 00:30:16,065
It's complement of NP.

518
00:30:18,990 --> 00:30:22,450
So for example, the complement
of the HAMPATH problem.

519
00:30:22,450 --> 00:30:27,600
So all the graphs which don't
have Hamiltonian paths from

520
00:30:27,600 --> 00:30:33,630
SAT, so the
non-Hamiltonian graph--

521
00:30:33,630 --> 00:30:36,300
the non-Hamiltonian
path problem--

522
00:30:36,300 --> 00:30:39,450
that's a coNP problem.

523
00:30:39,450 --> 00:30:41,190
Or here's a language
we haven't--

524
00:30:41,190 --> 00:30:45,480
I'm not going to define as
in terms of its complement--

525
00:30:45,480 --> 00:30:46,920
the tautology problem.

526
00:30:52,920 --> 00:30:55,920
These are the formulas
where all assignments

527
00:30:55,920 --> 00:30:57,450
satisfy the formula.

528
00:30:57,450 --> 00:31:01,750
All assignments make
the formula true.

529
00:31:01,750 --> 00:31:08,260
So a tautology is a
statement that's always true,

530
00:31:08,260 --> 00:31:09,940
no matter how you
plug in the variables.

531
00:31:12,510 --> 00:31:17,930
So the tautology
language is in coNP

532
00:31:17,930 --> 00:31:20,990
because its complement, which
is the non-tautologies-- those

533
00:31:20,990 --> 00:31:25,820
are the formulas for which
there's some assignment which

534
00:31:25,820 --> 00:31:26,960
makes it false.

535
00:31:26,960 --> 00:31:29,270
So that's going to be
clearly an NP language.

536
00:31:29,270 --> 00:31:32,720
So tautology is a coNP language.

537
00:31:37,810 --> 00:31:40,450
Now one thing that
we get immediately

538
00:31:40,450 --> 00:31:42,640
from the theorem
as a corollary--

539
00:31:42,640 --> 00:31:44,350
really should write
this as a corollary--

540
00:31:44,350 --> 00:31:51,100
is that coNP is also a subset of
PSPACE And the reason for that

541
00:31:51,100 --> 00:31:51,730
is--

542
00:31:51,730 --> 00:31:54,160
and this is something that--

543
00:31:54,160 --> 00:31:58,150
it's, again, easy,
but make sure you

544
00:31:58,150 --> 00:32:02,110
understand it-- is
that PSPACE itself

545
00:32:02,110 --> 00:32:07,310
is closed under complement
because it is defined in terms

546
00:32:07,310 --> 00:32:08,990
of deterministic machines.

547
00:32:08,990 --> 00:32:12,910
And deterministic machines--
you can always flip the answer

548
00:32:12,910 --> 00:32:20,260
and get a machine of the
same type which will decide

549
00:32:20,260 --> 00:32:23,420
the complementary language.

550
00:32:23,420 --> 00:32:25,930
So for deterministic machines--

551
00:32:25,930 --> 00:32:28,990
deterministic deciders,
I should say--

552
00:32:28,990 --> 00:32:32,500
you can always flip the answer.

553
00:32:32,500 --> 00:32:39,020
Now, so here, we have
anything that's in PSPACE.

554
00:32:39,020 --> 00:32:42,380
It has a deterministic
polynomial time--

555
00:32:42,380 --> 00:32:44,600
polynomial space-- machine.

556
00:32:44,600 --> 00:32:46,280
And so its
complementary language

557
00:32:46,280 --> 00:32:47,540
is also going to be in PSPACE.

558
00:32:47,540 --> 00:32:51,000
So PSPACE and
coPSPACE are equal.

559
00:32:51,000 --> 00:32:56,530
And so that's why coNP is
going to be in PSPACE--

560
00:32:56,530 --> 00:32:59,820
going to be a subset of PSPACE.

561
00:32:59,820 --> 00:33:03,430
I hope that's not
getting mixed up

562
00:33:03,430 --> 00:33:06,700
by all of the different
alphabet soup here.

563
00:33:06,700 --> 00:33:10,360
But here is maybe
a picture maybe

564
00:33:10,360 --> 00:33:13,690
that'll be helpful of
how the world looks

565
00:33:13,690 --> 00:33:19,930
for the time and space
complexity classes so far.

566
00:33:19,930 --> 00:33:23,830
So we have P is a subset of NP.

567
00:33:23,830 --> 00:33:29,700
It's also a subset of coNP,
again, for the same reason

568
00:33:29,700 --> 00:33:31,740
that P and coP are equal.

569
00:33:31,740 --> 00:33:38,970
We never even really talk about
coP because it's the same as P.

570
00:33:38,970 --> 00:33:40,740
But NP and coNP--

571
00:33:40,740 --> 00:33:42,240
those are two classes
where we don't

572
00:33:42,240 --> 00:33:49,230
know whether they're equal or
not, because an NP machine--

573
00:33:49,230 --> 00:33:54,120
you can't necessarily complement
the behavior of an NP machine

574
00:33:54,120 --> 00:33:56,160
and end up with an NP machine.

575
00:33:56,160 --> 00:33:58,470
So a question here--
how do we know

576
00:33:58,470 --> 00:34:01,680
that coNP is a complete
class of problems?

577
00:34:01,680 --> 00:34:04,200
I didn't say that there's
anything about completeness.

578
00:34:04,200 --> 00:34:06,900
And coNP is just a
collection of languages.

579
00:34:06,900 --> 00:34:08,590
I'm not saying it's any--

580
00:34:08,590 --> 00:34:10,750
any particular feature about it.

581
00:34:10,750 --> 00:34:12,989
In fact, it does have
a complete problem,

582
00:34:12,989 --> 00:34:16,199
just like NP has a
complete problem.

583
00:34:16,199 --> 00:34:18,480
The complements--
and I'm not going

584
00:34:18,480 --> 00:34:21,480
to prove this right here, though
it's pretty straightforward.

585
00:34:21,480 --> 00:34:23,639
Complements of all the
NP-complete languages

586
00:34:23,639 --> 00:34:25,710
are going to be
coNP-complete languages.

587
00:34:36,471 --> 00:34:37,929
I will answer some
of the questions

588
00:34:37,929 --> 00:34:42,190
about possible alternate worlds.

589
00:34:42,190 --> 00:34:44,350
This is how we believe
the world looks like,

590
00:34:44,350 --> 00:34:47,500
with each one of these regions
being separated from one

591
00:34:47,500 --> 00:34:50,920
another, including this little
corner of the world here,

592
00:34:50,920 --> 00:34:55,053
NP, and intersect
coNP, which is not--

593
00:34:55,053 --> 00:34:57,220
there might be languages
in here which are not in P.

594
00:34:57,220 --> 00:34:59,380
And we actually believe
there are such languages.

595
00:34:59,380 --> 00:35:02,560
But again, all of
this is conjectural.

596
00:35:02,560 --> 00:35:06,070
And even whether P and PSPACE
are the same or different

597
00:35:06,070 --> 00:35:08,217
is an open question.

598
00:35:08,217 --> 00:35:09,800
We don't even know
the answer to that,

599
00:35:09,800 --> 00:35:12,370
which is perhaps even
more shocking that we

600
00:35:12,370 --> 00:35:15,060
don't know how to solve P and--

601
00:35:15,060 --> 00:35:17,140
prove P different
from NP, that we

602
00:35:17,140 --> 00:35:19,480
don't know how to prove P
different from PSPACE, which

603
00:35:19,480 --> 00:35:21,700
seems to be a much bigger class.

604
00:35:21,700 --> 00:35:23,200
It would be incredible
that anything

605
00:35:23,200 --> 00:35:26,260
you can do with a
polynomial amount of space

606
00:35:26,260 --> 00:35:29,020
you can also do with a
polynomial amount of time.

607
00:35:29,020 --> 00:35:31,900
But don't know
how to prove that.

608
00:35:31,900 --> 00:35:32,680
They're different.

609
00:35:32,680 --> 00:35:35,770
And in fact, so this is
how the world could look.

610
00:35:39,150 --> 00:35:40,540
Everything could collapse down.

611
00:35:40,540 --> 00:35:42,270
P could equal PSPACE.

612
00:35:42,270 --> 00:35:46,095
And then all of these
classes would be the same.

613
00:35:46,095 --> 00:35:47,220
And I should also mention--

614
00:35:47,220 --> 00:35:49,080
I don't have this
as another diagram

615
00:35:49,080 --> 00:35:52,530
here, but just to answer--

616
00:35:52,530 --> 00:35:53,730
there's other possibilities.

617
00:35:53,730 --> 00:36:00,623
For example, P could equal NP
without being equal to PSPACE.

618
00:36:00,623 --> 00:36:02,790
And then you'd have a
different-looking Venn diagram

619
00:36:02,790 --> 00:36:04,920
here, where there'd
be just two classes.

620
00:36:04,920 --> 00:36:08,010
P, NP and coNP would
all be the same.

621
00:36:08,010 --> 00:36:09,360
PSPACE would be different.

622
00:36:09,360 --> 00:36:11,168
That's possible.

623
00:36:11,168 --> 00:36:12,210
At least we have no idea.

624
00:36:14,820 --> 00:36:20,340
A lot of these things can
collapse in various ways.

625
00:36:20,340 --> 00:36:22,980
And you just have
to make sure that--

626
00:36:22,980 --> 00:36:26,040
there are some collapses
that obviously could not

627
00:36:26,040 --> 00:36:27,630
occur, like P--

628
00:36:27,630 --> 00:36:31,770
if P equals NP, it's
also going to equal coNP.

629
00:36:31,770 --> 00:36:32,730
So you can't get--

630
00:36:32,730 --> 00:36:34,960
there are obviously
some crazy collapses

631
00:36:34,960 --> 00:36:36,990
which could not happen--

632
00:36:36,990 --> 00:36:39,300
that P collapsing-- P
and NP being the same,

633
00:36:39,300 --> 00:36:40,410
but different from coNP.

634
00:36:40,410 --> 00:36:41,700
That can't happen.

635
00:36:41,700 --> 00:36:49,070
But avoiding some obvious
contradictory situations,

636
00:36:49,070 --> 00:36:51,420
everything else is possible.

637
00:36:51,420 --> 00:36:53,570
So somebody said--
so here's a question.

638
00:36:53,570 --> 00:36:55,310
Let me just answer
a few of these.

639
00:36:55,310 --> 00:36:57,890
Did we use the
completeness of coNP

640
00:36:57,890 --> 00:37:02,960
to show that coNP is
a subset of coPSPACE?

641
00:37:02,960 --> 00:37:06,540
No, we didn't do it that way.

642
00:37:06,540 --> 00:37:08,780
We showed that coNP--

643
00:37:15,573 --> 00:37:16,240
well, let's see.

644
00:37:16,240 --> 00:37:16,810
Did we?

645
00:37:16,810 --> 00:37:17,650
Is that fair?

646
00:37:21,540 --> 00:37:24,000
Well, I suppose.

647
00:37:24,000 --> 00:37:27,000
NP of subset of
PSPACE immediately

648
00:37:27,000 --> 00:37:29,370
implies, because you're
complementing both sides,

649
00:37:29,370 --> 00:37:33,090
that coNP is a
subset of coPSPACE.

650
00:37:33,090 --> 00:37:36,090
So you don't have to deal
with the complete problems

651
00:37:36,090 --> 00:37:37,410
on the other side.

652
00:37:37,410 --> 00:37:39,870
That's too complicated
to get into here.

653
00:37:39,870 --> 00:37:44,010
You don't need to talk about
coNP-complete problems.

654
00:37:44,010 --> 00:37:46,680
Though, again, those
are very simple to get

655
00:37:46,680 --> 00:37:49,740
from NP-complete problems.

656
00:37:49,740 --> 00:37:53,100
Let's see what else is here.

657
00:37:53,100 --> 00:37:57,340
Are there NP-complete
problems that are in coNP?

658
00:37:57,340 --> 00:38:00,880
So the answer to that is, no,
not as far as-- well, I mean,

659
00:38:00,880 --> 00:38:04,900
there would be-- if there was
an NP-complete problem in coNP,

660
00:38:04,900 --> 00:38:09,330
then all of NP would be in
coNP, and they would be equal.

661
00:38:09,330 --> 00:38:12,565
So we suspect the NP-complete
problems are not in coNP,

662
00:38:12,565 --> 00:38:13,940
but don't know
how to prove that.

663
00:38:17,030 --> 00:38:20,780
So why is tautology in coNP?

664
00:38:20,780 --> 00:38:23,420
So here is-- tautology
sits in this class, here.

665
00:38:23,420 --> 00:38:25,610
The reason is that its
complementary language

666
00:38:25,610 --> 00:38:26,360
is in NP.

667
00:38:26,360 --> 00:38:30,200
The complement of
tautology are the languages

668
00:38:30,200 --> 00:38:35,750
where there is some assignment
which makes the formula false.

669
00:38:35,750 --> 00:38:39,230
So with an NP machine, you
can just guess that assignment

670
00:38:39,230 --> 00:38:41,960
and check that it makes
the formula false.

671
00:38:41,960 --> 00:38:45,770
So the complement of
tautology is an NP language.

672
00:38:45,770 --> 00:38:47,840
And so tautology
is a coNP language.

673
00:38:54,920 --> 00:38:57,830
So somebody's asking
about PSPACE and NPSPACE.

674
00:38:57,830 --> 00:38:59,550
And how do those
relate to one another?

675
00:38:59,550 --> 00:39:02,570
So that's looking
ahead to what we're

676
00:39:02,570 --> 00:39:05,750
going to be doing next week,
but I'll give you a preview.

677
00:39:09,150 --> 00:39:11,400
An old, but at the
time surprising,

678
00:39:11,400 --> 00:39:17,440
theorem was that PSPACE and
NPSPACE actually are equal.

679
00:39:17,440 --> 00:39:19,950
So they had this analogy
where time breaks down.

680
00:39:19,950 --> 00:39:22,800
So polynomial space and
non-deterministic polynomial

681
00:39:22,800 --> 00:39:26,040
space do turn out to be equal.

682
00:39:26,040 --> 00:39:28,260
The most obvious
way of proving--

683
00:39:28,260 --> 00:39:32,460
of trying to simulate
an an NPSPACE machine

684
00:39:32,460 --> 00:39:36,790
would be give you an exponential
deterministic space algorithm.

685
00:39:36,790 --> 00:39:38,130
So we'll go through that.

686
00:39:38,130 --> 00:39:41,670
But there is an
algorithm which collapses

687
00:39:41,670 --> 00:39:43,500
non-deterministic
polynomial space down

688
00:39:43,500 --> 00:39:45,990
to deterministic polynomial
space, which, again,

689
00:39:45,990 --> 00:39:47,760
at the time was
kind of surprising.

690
00:39:51,960 --> 00:39:53,100
Last question I'll take--

691
00:39:53,100 --> 00:39:55,140
is there some equivalent
concept to the idea

692
00:39:55,140 --> 00:39:57,870
of a certificate for coNP?

693
00:39:57,870 --> 00:39:59,910
Yes, there is a notion
of a certificate.

694
00:39:59,910 --> 00:40:02,760
But now it's going to be a
certificate that you're not

695
00:40:02,760 --> 00:40:05,040
in the language instead
of a certificate

696
00:40:05,040 --> 00:40:08,110
that you're in the
language, and then, again,

697
00:40:08,110 --> 00:40:10,630
work for the very same reason
that we have certificates

698
00:40:10,630 --> 00:40:13,930
for NP languages, where you
had certificate for membership.

699
00:40:13,930 --> 00:40:16,900
For coNP, you have certificate
for non-membership.

700
00:40:16,900 --> 00:40:21,070
There's no other certificate
for membership in coNP.

701
00:40:21,070 --> 00:40:21,940
So let's move on.

702
00:40:25,895 --> 00:40:27,270
So now we're going
to introduce--

703
00:40:27,270 --> 00:40:29,320
we're going to look at
some important examples.

704
00:40:29,320 --> 00:40:31,580
These are examples
that we're going to--

705
00:40:31,580 --> 00:40:33,330
I'm going to give you
two examples, first,

706
00:40:33,330 --> 00:40:34,860
one called TQBF.

707
00:40:34,860 --> 00:40:37,530
And then we're going to
have a second example.

708
00:40:37,530 --> 00:40:40,320
Both of those we're going to--

709
00:40:40,320 --> 00:40:43,857
one of them is going to be an
example of a problem in PSPACE.

710
00:40:43,857 --> 00:40:45,690
Then the other one is
going to be an example

711
00:40:45,690 --> 00:40:48,030
of a problem in NPSPACE.

712
00:40:48,030 --> 00:40:51,010
And these are going to be
important languages for us.

713
00:40:51,010 --> 00:40:54,150
So they're not just going to
serve as examples for today,

714
00:40:54,150 --> 00:40:59,140
but they're going to be useful
languages for us later on.

715
00:40:59,140 --> 00:41:04,170
So just keep that in mind
as we're going through it.

716
00:41:04,170 --> 00:41:08,870
So to understand TQBF,
you have to understand

717
00:41:08,870 --> 00:41:13,175
what are called quantified
Boolean formulas or QBFs.

718
00:41:15,850 --> 00:41:18,350
So those are Boolean formulas,
just like the ones we've been

719
00:41:18,350 --> 00:41:20,030
seeing-- we've been
talking about--

720
00:41:20,030 --> 00:41:25,460
with Boolean variables and the
ands/ors and negated variables.

721
00:41:25,460 --> 00:41:28,025
But now you're going
to add qualifiers,

722
00:41:28,025 --> 00:41:32,550
the "exists" quantifiers
and "for all" quantifiers.

723
00:41:32,550 --> 00:41:34,710
If you haven't seen
quantifiers, you

724
00:41:34,710 --> 00:41:38,340
need to go back
and review those.

725
00:41:38,340 --> 00:41:40,980
I think that we already
introduced-- talked about them

726
00:41:40,980 --> 00:41:43,350
briefly earlier in the term.

727
00:41:43,350 --> 00:41:47,070
But this is part of the basic
math that you need to know.

728
00:41:49,590 --> 00:41:51,870
Maybe you'll-- not
comfortable with them,

729
00:41:51,870 --> 00:41:55,380
you'll pick it up
somewhat during the course

730
00:41:55,380 --> 00:41:59,460
of today's and the next
few lectures, but anyway.

731
00:41:59,460 --> 00:42:02,513
So if you have a
Boolean formula--

732
00:42:02,513 --> 00:42:03,930
I'll give you some
examples-- that

733
00:42:03,930 --> 00:42:06,570
has "exists" and "for
all" quantifiers,

734
00:42:06,570 --> 00:42:08,970
the requirement
for it to be a QBF

735
00:42:08,970 --> 00:42:10,530
is that all of
the variables have

736
00:42:10,530 --> 00:42:14,100
to be within the scope of
one of the quantifiers.

737
00:42:14,100 --> 00:42:17,370
So all of the variables
of the formula

738
00:42:17,370 --> 00:42:20,070
have to be quantified by
one of the quantifiers.

739
00:42:20,070 --> 00:42:23,310
And we're going to assume the
quantifiers are in front--

740
00:42:23,310 --> 00:42:29,490
are leading quantifiers in front
of the rest of the expression.

741
00:42:32,510 --> 00:42:37,510
So because all of the
variables have been quantified,

742
00:42:37,510 --> 00:42:39,610
then a quantified
Boolean formula

743
00:42:39,610 --> 00:42:42,970
is going to be either
true or false following

744
00:42:42,970 --> 00:42:46,830
the meaning of the quantifiers.

745
00:42:46,830 --> 00:42:48,580
And again, some of
this may become clearer

746
00:42:48,580 --> 00:42:49,585
as we do some examples.

747
00:42:53,950 --> 00:42:56,210
So here are some
examples coming.

748
00:42:56,210 --> 00:42:57,820
So here is one--

749
00:42:57,820 --> 00:42:59,380
here is a QBF.

750
00:42:59,380 --> 00:43:02,320
So all of the variables,
which are just x and y--

751
00:43:02,320 --> 00:43:05,530
they both appear in front of--

752
00:43:05,530 --> 00:43:06,610
next to some quantifier.

753
00:43:06,610 --> 00:43:14,030
So that's going to be-- that's
a requirement if we have a QBF.

754
00:43:14,030 --> 00:43:18,560
And so this says, for
all x, there exists a y.

755
00:43:18,560 --> 00:43:23,120
This expression holds.

756
00:43:23,120 --> 00:43:26,500
So we need to unpack that
and understand what it means.

757
00:43:26,500 --> 00:43:28,540
It says, for every x--

758
00:43:28,540 --> 00:43:32,950
for every way of
assigning a Boolean value

759
00:43:32,950 --> 00:43:36,460
to x, so x is going to
be either true or false,

760
00:43:36,460 --> 00:43:39,970
there exists a way of
assigning a Boolean value for y

761
00:43:39,970 --> 00:43:41,810
to make this true--

762
00:43:41,810 --> 00:43:47,270
to make the rest of the
expression hold true.

763
00:43:47,270 --> 00:43:48,980
And we'll go through that.

764
00:43:48,980 --> 00:43:54,650
But let's contrast that with
the second example, where

765
00:43:54,650 --> 00:43:57,680
I invert the order
of the quantifiers,

766
00:43:57,680 --> 00:44:01,740
because that's going to be
important for the meaning

767
00:44:01,740 --> 00:44:04,580
of the formula.

768
00:44:04,580 --> 00:44:06,220
So if I say for
every x, there is

769
00:44:06,220 --> 00:44:11,090
a y, which makes the rest
of it true, that says,

770
00:44:11,090 --> 00:44:13,540
well, no matter how
I set x, there's

771
00:44:13,540 --> 00:44:15,950
going to be way to set
y to make this true.

772
00:44:15,950 --> 00:44:19,190
So that says, well, if I
set x to true, [AUDIO OUT]

773
00:44:19,190 --> 00:44:23,900
got to be some way to set y to
make the remaining expression

774
00:44:23,900 --> 00:44:25,410
hold.

775
00:44:25,410 --> 00:44:30,420
So if I set x to true,
what should I set y to be?

776
00:44:30,420 --> 00:44:36,990
Well, if I set x to be true,
maybe I could set y to be true.

777
00:44:36,990 --> 00:44:40,430
Well, then this
clause is satisfied,

778
00:44:40,430 --> 00:44:42,330
but this clause
won't be satisfied.

779
00:44:42,330 --> 00:44:45,560
So setting y to be true
is not-- it won't work.

780
00:44:45,560 --> 00:44:49,800
But for every x, I only need
to show there exists some y.

781
00:44:49,800 --> 00:44:55,260
So if I take x to be true,
I can set y to be false.

782
00:44:55,260 --> 00:44:57,330
And now this one
is-- this one holds,

783
00:44:57,330 --> 00:44:59,412
and this one holds,
and the formula holds.

784
00:44:59,412 --> 00:45:00,870
But I have to make
sure that that's

785
00:45:00,870 --> 00:45:03,630
going to be the case
for both settings of x

786
00:45:03,630 --> 00:45:05,700
because I'm saying for all x.

787
00:45:05,700 --> 00:45:08,372
So if I set x now to
false, because I already

788
00:45:08,372 --> 00:45:10,080
showed that it works
for x equal to true,

789
00:45:10,080 --> 00:45:15,070
if I set x equal to false,
if I set now y to be true,

790
00:45:15,070 --> 00:45:16,760
this is going to hold.

791
00:45:16,760 --> 00:45:21,890
So this expression
is true, because it

792
00:45:21,890 --> 00:45:23,960
is the case that for
every way to set x,

793
00:45:23,960 --> 00:45:25,730
there is a way to set y.

794
00:45:25,730 --> 00:45:27,620
So this part holds.

795
00:45:27,620 --> 00:45:30,200
Let's compare that
with this case.

796
00:45:30,200 --> 00:45:36,790
Is there some way to set y such
that no matter how I set x,

797
00:45:36,790 --> 00:45:39,197
this is going to hold?

798
00:45:39,197 --> 00:45:40,530
And that's not going to be true.

799
00:45:40,530 --> 00:45:44,120
No matter what you
pick for y, there

800
00:45:44,120 --> 00:45:47,800
is going to be some way to
set x to make this false.

801
00:45:47,800 --> 00:45:51,210
So does there exist a y such
that every x makes this true?

802
00:45:51,210 --> 00:45:52,320
No.

803
00:45:52,320 --> 00:45:55,380
If you try x equal to true,
it's not going to work.

804
00:45:55,380 --> 00:45:58,150
If you try x equal to false,
it's not going to work.

805
00:45:58,150 --> 00:46:03,835
So this second phi 2
expression-- quantified QBF--

806
00:46:03,835 --> 00:46:04,335
is false.

807
00:46:07,110 --> 00:46:09,640
We're going to be
playing with these a lot.

808
00:46:09,640 --> 00:46:15,870
So it's important to understand
how this quantification works.

809
00:46:15,870 --> 00:46:21,870
So TQBF is the problem
of testing whether one

810
00:46:21,870 --> 00:46:24,180
of these QBFs is true.

811
00:46:24,180 --> 00:46:30,630
Or phrased as a language, it's
the collection of true QBFs.

812
00:46:30,630 --> 00:46:36,105
And that's where we
get the acronym TQBF--

813
00:46:36,105 --> 00:46:40,332
not acronym, the abbreviation
TQBF for the True Quantified

814
00:46:40,332 --> 00:46:41,040
Boolean Formulas.

815
00:46:45,830 --> 00:46:48,790
So going back to
that example, phi 1

816
00:46:48,790 --> 00:46:50,530
is a true quantified
Boolean formula,

817
00:46:50,530 --> 00:46:53,930
and phi 2 is not a true
quantified Boolean formula.

818
00:46:53,930 --> 00:46:56,087
So that's why phi 1
is in the language.

819
00:46:56,087 --> 00:46:57,295
Phi 2 is not in the language.

820
00:47:00,450 --> 00:47:03,420
Now our computational
problem is to test

821
00:47:03,420 --> 00:47:08,660
whether quantified Boolean
formulas are true or not.

822
00:47:08,660 --> 00:47:11,370
And then we can do it
in polynomial space.

823
00:47:11,370 --> 00:47:12,600
Oh, there's a Check-in first.

824
00:47:16,200 --> 00:47:21,850
I claim that SAT is a
special case of TQBF.

825
00:47:21,850 --> 00:47:23,430
Why is that?

826
00:47:23,430 --> 00:47:28,350
How can we think of
SAT as a special case?

827
00:47:28,350 --> 00:47:31,500
If I give you a SAT
formula, how can I

828
00:47:31,500 --> 00:47:34,560
see that as also a TQBF problem?

829
00:47:34,560 --> 00:47:37,788
If you want to test if
that formula is true,

830
00:47:37,788 --> 00:47:38,580
what would you say?

831
00:47:38,580 --> 00:47:42,270
Remove all the quantifiers
or add some quantifiers?

832
00:47:42,270 --> 00:47:44,820
And what kind of
quantifiers, maybe?

833
00:47:47,890 --> 00:47:52,890
How is SAT, just testing
a formula is satisfiable,

834
00:47:52,890 --> 00:47:54,720
a special case of this--

835
00:47:54,720 --> 00:47:56,520
what I claim is a
more general problem

836
00:47:56,520 --> 00:47:59,385
of solving these TQBF problems?

837
00:48:02,720 --> 00:48:05,355
Closing down.

838
00:48:05,355 --> 00:48:05,855
Last call.

839
00:48:11,250 --> 00:48:12,600
Yes, indeed.

840
00:48:12,600 --> 00:48:17,040
Satisfiability--
so C is correct.

841
00:48:17,040 --> 00:48:19,260
When you're talking about
a satisfiability problem,

842
00:48:19,260 --> 00:48:22,440
you're saying, is there
a satisfying assignment?

843
00:48:22,440 --> 00:48:28,800
Another way of writing that down
is take that Boolean formula

844
00:48:28,800 --> 00:48:32,160
and put "exists" in front
of all the variables.

845
00:48:35,430 --> 00:48:39,390
Does there exist a way to
set x1 and x2 and x3 and x4

846
00:48:39,390 --> 00:48:43,740
to make the formula true--
to make that formula hold?

847
00:48:43,740 --> 00:48:49,770
So SAT is a special case
by aiding exist qualifiers

848
00:48:49,770 --> 00:48:52,430
of a TQBF problem.

849
00:48:52,430 --> 00:48:53,140
So C is correct.

850
00:48:57,620 --> 00:49:02,290
So why is this problem
in PSPACE, as I claimed?

851
00:49:02,290 --> 00:49:05,830
And for that, we're going
to give a simple recursive

852
00:49:05,830 --> 00:49:08,212
algorithm.

853
00:49:08,212 --> 00:49:11,575
In any quantified
Boolean formula--

854
00:49:11,575 --> 00:49:13,450
now, if you want to test
if it's true or not,

855
00:49:13,450 --> 00:49:20,140
we're going to basically strip
off the leading quantifiers.

856
00:49:20,140 --> 00:49:22,120
So if it's an exist
quantifier, we'll

857
00:49:22,120 --> 00:49:25,630
remove it and plug
in true and false

858
00:49:25,630 --> 00:49:32,080
associated to its variable,
and then solve those problems

859
00:49:32,080 --> 00:49:32,860
recursively.

860
00:49:35,980 --> 00:49:40,630
So this is just going to be a
recursive procedure for solving

861
00:49:40,630 --> 00:49:44,390
TQBF problems, operating
by stripping off

862
00:49:44,390 --> 00:49:47,682
the quantifiers in
front and getting

863
00:49:47,682 --> 00:49:48,890
smaller and smaller formulas.

864
00:49:48,890 --> 00:49:50,307
But now we're going
to be plugging

865
00:49:50,307 --> 00:49:53,690
in values, true
and false, instead

866
00:49:53,690 --> 00:50:01,070
of relying on the
quantifier to give us

867
00:50:01,070 --> 00:50:02,195
the meaning of the formula.

868
00:50:04,920 --> 00:50:07,110
So first of all, if
there are no quantifiers,

869
00:50:07,110 --> 00:50:09,960
then there are no variables,
because all variables have to--

870
00:50:09,960 --> 00:50:11,370
bound within quantifiers.

871
00:50:11,370 --> 00:50:15,060
And in that case, that
quantified Boolean formula

872
00:50:15,060 --> 00:50:18,750
has to simply be the statement
true or the statement false.

873
00:50:18,750 --> 00:50:20,520
And so you're going
to output accordingly

874
00:50:20,520 --> 00:50:24,560
because that's all it can
be if you have no variables.

875
00:50:24,560 --> 00:50:29,310
If the formula starts
with an exists quantifier,

876
00:50:29,310 --> 00:50:31,000
what you're going to do--

877
00:50:31,000 --> 00:50:34,080
so here, psi is the
remainder of the formula

878
00:50:34,080 --> 00:50:37,140
after you strip off
that exist quantifier.

879
00:50:37,140 --> 00:50:39,720
So you're going to
evaluate psi now, but take

880
00:50:39,720 --> 00:50:42,510
that variable that was
bound by the exists

881
00:50:42,510 --> 00:50:48,340
and just plug in true
and false respectively.

882
00:50:48,340 --> 00:50:53,490
So you're going to get
two, now, new problems,

883
00:50:53,490 --> 00:51:00,990
and run them and evaluate
them using the same procedure

884
00:51:00,990 --> 00:51:04,590
recursively, but now
with x plugged in for--

885
00:51:04,590 --> 00:51:06,960
true plugged in for x,
and also then with false

886
00:51:06,960 --> 00:51:09,450
plugged in for x--

887
00:51:09,450 --> 00:51:13,440
and get the answers
for those two cases.

888
00:51:13,440 --> 00:51:17,170
And if either one of
them ended up accepting,

889
00:51:17,170 --> 00:51:19,260
then you're going to
accept, because there exists

890
00:51:19,260 --> 00:51:24,360
a value of 4x which makes
the whole thing true,

891
00:51:24,360 --> 00:51:29,130
because you just
recursively showed

892
00:51:29,130 --> 00:51:31,650
that there was such a
value, either true or false,

893
00:51:31,650 --> 00:51:33,210
the thing has accepted.

894
00:51:33,210 --> 00:51:36,490
And if both of them fail,
then you're going to reject.

895
00:51:36,490 --> 00:51:40,810
And the very same idea if you
have a for all quantifier.

896
00:51:40,810 --> 00:51:44,890
You're going to evaluate the
remainder of the formula,

897
00:51:44,890 --> 00:51:49,800
again, with x equal to true and
false, so as two subproblems.

898
00:51:49,800 --> 00:51:51,300
But now you're going
to require them

899
00:51:51,300 --> 00:51:54,510
both to accept because that's
the meaning of for all--

900
00:51:54,510 --> 00:51:58,740
that both assignments to x
have to make the formula true.

901
00:51:58,740 --> 00:52:02,100
So you're going to evaluate
them recursively and accept

902
00:52:02,100 --> 00:52:07,740
if both of them are true, as
determined by your recursive--

903
00:52:07,740 --> 00:52:09,780
your recursion.

904
00:52:09,780 --> 00:52:12,868
So how much space does this use?

905
00:52:12,868 --> 00:52:14,910
I'm not going to go through
this in great detail.

906
00:52:14,910 --> 00:52:20,450
But each recursive level
uses just a constant amount

907
00:52:20,450 --> 00:52:21,240
of space.

908
00:52:21,240 --> 00:52:22,880
So every time you
do a recursion,

909
00:52:22,880 --> 00:52:27,380
you have to remember
that that value--

910
00:52:27,380 --> 00:52:30,805
that assignment
to that variable.

911
00:52:30,805 --> 00:52:32,430
You want to think of
recursion as being

912
00:52:32,430 --> 00:52:33,960
implemented on a stack.

913
00:52:33,960 --> 00:52:36,150
So you're just going to
pop-- push on the stack

914
00:52:36,150 --> 00:52:40,690
that value of that variable,
which is that true or false.

915
00:52:40,690 --> 00:52:44,040
So basically it's
1 bit of memory

916
00:52:44,040 --> 00:52:47,040
that you're going to require
every time you're going down

917
00:52:47,040 --> 00:52:48,420
the recursion.

918
00:52:48,420 --> 00:52:50,100
You just have to remember what--

919
00:52:52,650 --> 00:52:57,090
which case you're working on,
whether x equal to true or x

920
00:52:57,090 --> 00:53:00,100
equal to false.

921
00:53:00,100 --> 00:53:05,320
And so each recursive level
just involves constant space.

922
00:53:05,320 --> 00:53:07,480
And the depth of the recursion--

923
00:53:07,480 --> 00:53:09,430
how much might you
have to remember?

924
00:53:09,430 --> 00:53:12,970
Well, it's going to be at
most 1 for every quantifier,

925
00:53:12,970 --> 00:53:13,765
because that's--

926
00:53:13,765 --> 00:53:15,223
you're stripping
them off as you're

927
00:53:15,223 --> 00:53:16,370
going down the recursion.

928
00:53:16,370 --> 00:53:19,150
So that's going to be at most
the length of the formula.

929
00:53:19,150 --> 00:53:22,220
That's at most the number
of quantifiers you can have.

930
00:53:22,220 --> 00:53:25,510
And so the total amount
of space used by this

931
00:53:25,510 --> 00:53:29,900
is going to be just n, order n.

932
00:53:29,900 --> 00:53:35,010
So this problem is
solved in NSPACE,

933
00:53:35,010 --> 00:53:38,500
and so that's why
it's in PSPACE.

934
00:53:38,500 --> 00:53:41,480
I think that's all I
wanted to say about this.

935
00:53:46,890 --> 00:53:48,630
If we regard the tape
in a Turing machine

936
00:53:48,630 --> 00:53:51,960
as memory in a modern computer,
what does the finite control

937
00:53:51,960 --> 00:53:53,220
correspond to?

938
00:53:53,220 --> 00:53:54,990
The finite control
corresponds to just

939
00:53:54,990 --> 00:53:57,840
a finite additional memory.

940
00:53:57,840 --> 00:54:00,570
The tape is an unlimited
amount of memory.

941
00:54:00,570 --> 00:54:03,180
Or if we're putting
bounds, the amount

942
00:54:03,180 --> 00:54:06,510
of tape is going to be,
say, n squared memory,

943
00:54:06,510 --> 00:54:07,950
where n is the length of m--

944
00:54:07,950 --> 00:54:09,510
n is the length of the input.

945
00:54:09,510 --> 00:54:17,040
So, yeah, they're both memories,
but the finite control is--

946
00:54:17,040 --> 00:54:18,310
it doesn't grow with n.

947
00:54:18,310 --> 00:54:23,543
So that's going to be just
some constant amount of memory.

948
00:54:23,543 --> 00:54:25,710
What would be the time
complexity of this algorithm?

949
00:54:25,710 --> 00:54:28,260
Time complexity would be bad.

950
00:54:28,260 --> 00:54:29,513
It's going to be exponential.

951
00:54:29,513 --> 00:54:31,180
So you'd have to just
double-check that.

952
00:54:31,180 --> 00:54:34,020
But it's going to
be something like 2

953
00:54:34,020 --> 00:54:37,170
to the number of
variables that you have--

954
00:54:37,170 --> 00:54:40,500
2 the number of quantifiers,
plus some small overhead

955
00:54:40,500 --> 00:54:42,935
for evaluating the
formula multiple time.

956
00:54:42,935 --> 00:54:44,310
But it's going to
be exponential.

957
00:54:47,550 --> 00:54:48,930
What else can I answer for you?

958
00:54:57,570 --> 00:55:00,927
So someone is asking,
going back again to coNP,

959
00:55:00,927 --> 00:55:03,260
and how do we know there
exists a problem in coNP that's

960
00:55:03,260 --> 00:55:04,280
coNP-complete?

961
00:55:04,280 --> 00:55:06,470
We didn't define
even what that means.

962
00:55:06,470 --> 00:55:10,490
But coNP-complete
means-- we're going

963
00:55:10,490 --> 00:55:14,030
to start seeing other
examples of completeness

964
00:55:14,030 --> 00:55:15,830
for different
complexity classes.

965
00:55:15,830 --> 00:55:19,355
In particular, one thing that's
going to happen on Tuesday

966
00:55:19,355 --> 00:55:24,330
is we'll see a problem
that's complete for PSPACE.

967
00:55:24,330 --> 00:55:27,530
In fact, it's going to be TQBF.

968
00:55:27,530 --> 00:55:32,500
So looking ahead is going to
be a PSPACE-complete problem.

969
00:55:32,500 --> 00:55:35,320
But we even have
to have the notion

970
00:55:35,320 --> 00:55:39,100
of what we mean by complete
for these other classes.

971
00:55:39,100 --> 00:55:43,030
And in the case of coNP,
a problem is coNP-complete

972
00:55:43,030 --> 00:55:47,380
if it's in coNP, and
every other coNP problem

973
00:55:47,380 --> 00:55:50,170
is polynomial time-reducible
to it, so just exactly

974
00:55:50,170 --> 00:55:54,730
the same as we had for NP,
just plugging in coNP instead.

975
00:55:54,730 --> 00:56:01,320
And you just have to
work through the logic,

976
00:56:01,320 --> 00:56:03,430
but it's pretty straightforward.

977
00:56:03,430 --> 00:56:06,360
The complement of any
NP-complete problem

978
00:56:06,360 --> 00:56:12,010
is going to be a coNP-complete
problem using that definition.

979
00:56:12,010 --> 00:56:17,100
So I don't want to go through
that, those simple steps.

980
00:56:17,100 --> 00:56:19,770
But you just can go and
verify that offline--

981
00:56:19,770 --> 00:56:21,665
that that's going to be true.

982
00:56:21,665 --> 00:56:23,790
And I think we're going to
probably talk about that

983
00:56:23,790 --> 00:56:25,350
later in the semester, too.

984
00:56:29,020 --> 00:56:33,580
So another question-- how
does the TQBF algorithm--

985
00:56:37,450 --> 00:56:40,320
ah, that is a good
question here.

986
00:56:40,320 --> 00:56:45,000
Why is the TQBF algorithm that
I just described in PSPACE?

987
00:56:45,000 --> 00:56:47,940
Doesn't the thing-- every
time I'm doing a recursion,

988
00:56:47,940 --> 00:56:50,070
doesn't things branch
out so that I end up

989
00:56:50,070 --> 00:56:52,080
using exponential space?

990
00:56:52,080 --> 00:56:55,780
Critical thing which I actually
don't think I mentioned,

991
00:56:55,780 --> 00:56:57,480
which I think is
important to observe,

992
00:56:57,480 --> 00:57:00,780
is that when you're doing
those two recursive calls, when

993
00:57:00,780 --> 00:57:04,300
you set x equal to true
and set x equal to false,

994
00:57:04,300 --> 00:57:07,320
after you've determined
the answer for when you set

995
00:57:07,320 --> 00:57:11,190
x equal to true, now
you reuse that space,

996
00:57:11,190 --> 00:57:14,160
that very same space,
to test what happens

997
00:57:14,160 --> 00:57:16,410
when you have x equal to false.

998
00:57:16,410 --> 00:57:18,720
So that's the power
of space, which

999
00:57:18,720 --> 00:57:21,970
makes it different from time,
is that it can be reused.

1000
00:57:21,970 --> 00:57:24,090
So after you've got
the answer for when

1001
00:57:24,090 --> 00:57:27,270
you have x equal to true,
now you free up that space.

1002
00:57:27,270 --> 00:57:29,100
That's no longer needed anymore.

1003
00:57:29,100 --> 00:57:30,570
You just remember the answer.

1004
00:57:30,570 --> 00:57:33,070
And now you see what happens
when you have x equal to false,

1005
00:57:33,070 --> 00:57:34,180
using that same space.

1006
00:57:34,180 --> 00:57:36,390
So there's no
exponential blow-up.

1007
00:57:36,390 --> 00:57:37,640
That's an important point.

1008
00:57:37,640 --> 00:57:41,950
I'm glad you gave me
the chance to say it.

1009
00:57:41,950 --> 00:57:44,050
So somebody's asking
about defining

1010
00:57:44,050 --> 00:57:45,800
time of a non-deterministic
Turing machine

1011
00:57:45,800 --> 00:57:48,885
to the maximum time
of each branch.

1012
00:57:48,885 --> 00:57:50,510
Well, that's sort of
what we have done.

1013
00:57:50,510 --> 00:57:52,135
Maybe I don't understand
your question.

1014
00:57:52,135 --> 00:57:55,460
But you'll have to
ask it afterward

1015
00:57:55,460 --> 00:58:00,920
because I don't want to be
delaying any more than we have.

1016
00:58:00,920 --> 00:58:07,010
So we're going to go
back and move on, here.

1017
00:58:13,130 --> 00:58:17,660
Second example-- and this one
is a kind of a fun example,

1018
00:58:17,660 --> 00:58:20,330
but it's also going to be
an important one for us.

1019
00:58:20,330 --> 00:58:23,030
It's called the Ladder Problem.

1020
00:58:23,030 --> 00:58:25,750
So you may have seen something
called a word ladder.

1021
00:58:25,750 --> 00:58:29,450
But in general, a ladder
is a sequence of strings

1022
00:58:29,450 --> 00:58:31,600
which are all of
the same length,

1023
00:58:31,600 --> 00:58:34,195
but where consecutive strings
differ in a single symbol.

1024
00:58:40,810 --> 00:58:43,390
So for example, if you a
word ladder for English,

1025
00:58:43,390 --> 00:58:46,240
it's going to be a ladder
where all the words are--

1026
00:58:46,240 --> 00:58:49,360
all of the strings
are English words.

1027
00:58:49,360 --> 00:58:52,262
So here's an example.

1028
00:58:52,262 --> 00:58:53,610
I thought I fixed that.

1029
00:58:53,610 --> 00:59:02,160
OK, here is a word
ladder for English.

1030
00:59:02,160 --> 00:59:03,810
And maybe you've seen these.

1031
00:59:03,810 --> 00:59:07,640
Suppose I want to try to
get from "work" to "play."

1032
00:59:07,640 --> 00:59:11,900
But all of the
intermediate strings

1033
00:59:11,900 --> 00:59:16,250
should be English words
with four letters that

1034
00:59:16,250 --> 00:59:20,510
differ from their previous
one in only a single letter.

1035
00:59:20,510 --> 00:59:24,260
And I want to somehow change the
word "work" to the word "play."

1036
00:59:24,260 --> 00:59:26,300
So I don't know if you know.

1037
00:59:26,300 --> 00:59:30,660
So for example, I can
change "work" to "pork."

1038
00:59:30,660 --> 00:59:33,840
So here's just one
letter difference,

1039
00:59:33,840 --> 00:59:36,070
which looks like it's an
improvement, because now I

1040
00:59:36,070 --> 00:59:36,570
have the--

1041
00:59:36,570 --> 00:59:39,600
I'm in agreement on the play.

1042
00:59:39,600 --> 00:59:41,270
But sometimes, you
might change it.

1043
00:59:41,270 --> 00:59:43,020
You might have a good
change, and then you

1044
00:59:43,020 --> 00:59:46,930
have to undo it later, which
I think actually happens here.

1045
00:59:46,930 --> 00:59:49,140
So "pork" then is "port."

1046
00:59:49,140 --> 00:59:52,050
But then we gave
up that progress.

1047
00:59:52,050 --> 00:59:58,535
We made "port" to "sort"
to "suit" to "slot."

1048
00:59:58,535 --> 01:00:00,410
You've got to understand
what I'm doing here.

1049
01:00:00,410 --> 01:00:03,470
Each case, I'm just
changing a single letter.

1050
01:00:03,470 --> 01:00:05,130
But all of these words--

1051
01:00:05,130 --> 01:00:07,520
all of these have to be
legitimate English words

1052
01:00:07,520 --> 01:00:09,400
of length 4.

1053
01:00:09,400 --> 01:00:12,970
"Plot," "ploy,"
and then "play"--

1054
01:00:15,720 --> 01:00:17,762
so that's what a word
ladder in English would be.

1055
01:00:17,762 --> 01:00:19,762
Of course, you can do it
in different languages.

1056
01:00:19,762 --> 01:00:22,020
And now I'm going to
talk about it abstractly,

1057
01:00:22,020 --> 01:00:27,060
where instead of having a
natural human language as being

1058
01:00:27,060 --> 01:00:30,990
the test for a word--

1059
01:00:30,990 --> 01:00:33,390
for being-- a string
being legitimate--

1060
01:00:33,390 --> 01:00:37,560
I'm going to define
any old language.

1061
01:00:40,175 --> 01:00:43,970
Let's say A is going to be some
language, some set of strings.

1062
01:00:43,970 --> 01:00:46,940
And those are going to
be the legal strings that

1063
01:00:46,940 --> 01:00:49,090
can be in the ladder.

1064
01:00:49,090 --> 01:00:51,040
So ladder A is a
ladder of strings

1065
01:00:51,040 --> 01:00:54,310
that are all members of A.

1066
01:00:54,310 --> 01:01:01,200
And now the ladder
DFA problem is A going

1067
01:01:01,200 --> 01:01:03,840
to be the language of some DFA.

1068
01:01:03,840 --> 01:01:11,290
So I'm giving you B and then a
start string and an end string.

1069
01:01:11,290 --> 01:01:13,090
So this is like work and play.

1070
01:01:13,090 --> 01:01:16,870
U and v are like work and
play, so where B is a DFA.

1071
01:01:16,870 --> 01:01:21,430
And its language has a
ladder that goes from u to v,

1072
01:01:21,430 --> 01:01:23,035
and here are the
intermediate strings.

1073
01:01:36,840 --> 01:01:44,190
All right, so I'm going to
show you that this ladder DFA

1074
01:01:44,190 --> 01:01:45,180
problem is an NPSPACE.

1075
01:01:48,800 --> 01:01:52,160
This not super hard
because basically--

1076
01:01:52,160 --> 01:01:56,600
well, let's just actually
look at the slide here.

1077
01:01:56,600 --> 01:01:58,920
The way it's going to work
is it's nondeterministically

1078
01:01:58,920 --> 01:02:01,430
going to guess that
sequence from u to v.

1079
01:02:01,430 --> 01:02:05,280
So if I'm trying to get from
work to play, imagine those--

1080
01:02:05,280 --> 01:02:09,020
I'm going to be
using this in place

1081
01:02:09,020 --> 01:02:13,970
of the language of
my finite automaton,

1082
01:02:13,970 --> 01:02:15,780
just because this is
easier to talk about.

1083
01:02:15,780 --> 01:02:17,540
But imagine these
are being strings

1084
01:02:17,540 --> 01:02:22,190
that are accepted by that DFA.

1085
01:02:22,190 --> 01:02:25,490
So now I'm trying to get from
my string u to the string v.

1086
01:02:25,490 --> 01:02:26,360
And I want to test.

1087
01:02:26,360 --> 01:02:31,150
Can I get there by changing
one letter at a time,

1088
01:02:31,150 --> 01:02:34,375
but staying at strings that
are accepted by the DFA?

1089
01:02:37,590 --> 01:02:42,600
I'm just going to guess that
sequence nondeterministically.

1090
01:02:42,600 --> 01:02:46,230
But I have to make sure--
careful of two things.

1091
01:02:46,230 --> 01:02:49,290
I don't want to guess the
sequence all in advance

1092
01:02:49,290 --> 01:02:52,970
because that sequence might
be exponentially long.

1093
01:02:52,970 --> 01:02:55,150
You have to calculate how
long it could possibly be.

1094
01:02:55,150 --> 01:02:59,458
But you might change
to one symbol,

1095
01:02:59,458 --> 01:03:01,000
then change it to
a different symbol,

1096
01:03:01,000 --> 01:03:04,060
then change it back to
that original symbol.

1097
01:03:04,060 --> 01:03:07,180
So the only bound that
you can write down

1098
01:03:07,180 --> 01:03:08,710
is the number of
possible strings

1099
01:03:08,710 --> 01:03:11,140
that you can have
of that length.

1100
01:03:11,140 --> 01:03:13,000
So it might be exponential.

1101
01:03:13,000 --> 01:03:15,010
You don't want to write
down that whole thing

1102
01:03:15,010 --> 01:03:18,880
because that's going to be
exceeding your space bound.

1103
01:03:18,880 --> 01:03:20,390
But you don't need to.

1104
01:03:20,390 --> 01:03:23,350
You're just going to
guess them one at a time,

1105
01:03:23,350 --> 01:03:24,855
forgetting about
the previous one.

1106
01:03:24,855 --> 01:03:28,300
So just keep guessing the
next one in the sequence

1107
01:03:28,300 --> 01:03:31,770
and only remembering
that one and seeing

1108
01:03:31,770 --> 01:03:38,150
if you ever get to the
string-- your target string.

1109
01:03:38,150 --> 01:03:40,520
But then when you do that,
you have to make sure

1110
01:03:40,520 --> 01:03:43,680
that you don't end
up going forever,

1111
01:03:43,680 --> 01:03:52,680
because that's not allowed
in your NPSPACE algorithm.

1112
01:03:52,680 --> 01:03:55,580
So you're going to
have to keep a counter

1113
01:03:55,580 --> 01:03:59,057
to make sure that if you
go beyond that bound, which

1114
01:03:59,057 --> 01:04:00,890
is going to be the
maximum number of strings

1115
01:04:00,890 --> 01:04:02,450
you could possibly
have, then you're

1116
01:04:02,450 --> 01:04:06,230
going to just shut that branch
of the nondeterminism off.

1117
01:04:06,230 --> 01:04:08,870
You're going to just
reject on that branch.

1118
01:04:08,870 --> 01:04:10,430
So here is-- I'm
going to write--

1119
01:04:10,430 --> 01:04:13,580
say this here.

1120
01:04:13,580 --> 01:04:19,870
Here is my nondeterministic
polynomial space procedure.

1121
01:04:19,870 --> 01:04:25,330
I'm given my language-- my DFA
B and my start and end strings.

1122
01:04:25,330 --> 01:04:29,320
I let y equal to start string.

1123
01:04:29,320 --> 01:04:31,780
Write down the
length of my strings

1124
01:04:31,780 --> 01:04:35,560
that I'm going to have to keep
in mind all the way through.

1125
01:04:35,560 --> 01:04:38,140
And then I'm going to just
repeat the following t

1126
01:04:38,140 --> 01:04:41,470
times, where t is the
maximum length this can be,

1127
01:04:41,470 --> 01:04:45,310
which is the size of the
alphabet of these things

1128
01:04:45,310 --> 01:04:50,348
to the mth power, where m is
the length of those strings.

1129
01:04:50,348 --> 01:04:52,390
And I'm just going to
nondeterministically change

1130
01:04:52,390 --> 01:04:56,320
one symbol at a time,
making sure that I'm

1131
01:04:56,320 --> 01:05:00,720
staying in the language,
so rejecting immediately

1132
01:05:00,720 --> 01:05:04,710
if that change introduced a
string outside the language,

1133
01:05:04,710 --> 01:05:06,660
and accepting if
that string that I

1134
01:05:06,660 --> 01:05:13,840
get by changing that single
symbol is now my target.

1135
01:05:13,840 --> 01:05:16,600
And if I've gone
through my bound,

1136
01:05:16,600 --> 01:05:20,450
and I haven't managed
to reach that target,

1137
01:05:20,450 --> 01:05:21,700
then I'm just going to reject.

1138
01:05:25,760 --> 01:05:30,910
And we just have to observe
that this algorithm doesn't

1139
01:05:30,910 --> 01:05:32,360
use too much space.

1140
01:05:32,360 --> 01:05:34,660
So if you imagine
what we need here,

1141
01:05:34,660 --> 01:05:38,200
here's my input, u and
v, which is a blanked n,

1142
01:05:38,200 --> 01:05:39,580
and the total amount of space.

1143
01:05:39,580 --> 01:05:48,120
I just have to
remember the current y

1144
01:05:48,120 --> 01:05:51,840
and also my counter
t, my counter up to t.

1145
01:05:51,840 --> 01:05:58,320
So each of those can be written
down essentially in space.

1146
01:05:58,320 --> 01:06:02,740
So the total amount is
going to be order n space.

1147
01:06:02,740 --> 01:06:06,700
So that shows that this
ladder DFA problem is actually

1148
01:06:06,700 --> 01:06:09,250
in nondeterministic space n--

1149
01:06:09,250 --> 01:06:10,600
nondeterministic linear space.

1150
01:06:14,580 --> 01:06:18,540
And what we're
going to show next

1151
01:06:18,540 --> 01:06:20,850
is that this
language is actually

1152
01:06:20,850 --> 01:06:22,590
solvable in deterministic space.

1153
01:06:22,590 --> 01:06:24,360
And this is perhaps
a bit of a surprise.

1154
01:06:30,940 --> 01:06:32,620
So what's the size of the input?

1155
01:06:32,620 --> 01:06:37,460
The size of the
input is going to be

1156
01:06:37,460 --> 01:06:43,160
what it takes to write down
the DFA and the two strings, u

1157
01:06:43,160 --> 01:06:52,800
and v. So here, yeah,
I mean, I should

1158
01:06:52,800 --> 01:06:56,335
have also included as part of
the input the description of B

1159
01:06:56,335 --> 01:06:56,835
itself.

1160
01:07:01,920 --> 01:07:06,240
But that's going to be
more in my favor because--

1161
01:07:06,240 --> 01:07:08,370
this is slightly
incorrect, because B

1162
01:07:08,370 --> 01:07:10,620
itself has to appear
as part of the input,

1163
01:07:10,620 --> 01:07:12,220
so apologies for that.

1164
01:07:12,220 --> 01:07:15,030
But still, the
amount of space used

1165
01:07:15,030 --> 01:07:17,880
is going to be order n,
because these are going

1166
01:07:17,880 --> 01:07:19,230
to be actually less than n.

1167
01:07:24,110 --> 01:07:26,070
So we don't run out of
time for the lecture,

1168
01:07:26,070 --> 01:07:29,105
we can save additional
questions for afterward.

1169
01:07:29,105 --> 01:07:30,605
I'll stick around
for a few minutes.

1170
01:07:30,605 --> 01:07:33,650
But I just really have
one more slide here,

1171
01:07:33,650 --> 01:07:36,140
and that is proving
this theorem that ladder

1172
01:07:36,140 --> 01:07:38,950
can be done deterministically
in polynomial space.

1173
01:07:38,950 --> 01:07:43,093
And that's going to be
important as a kind of preview

1174
01:07:43,093 --> 01:07:44,885
of what we're going to
be doing on Tuesday.

1175
01:07:50,840 --> 01:07:54,260
If this goes a little fast, I'll
go over it again on Tuesday.

1176
01:07:54,260 --> 01:07:55,970
So let's just see how it goes.

1177
01:07:55,970 --> 01:08:01,240
So I'm going to show the same
ladder DFA problem is solvable

1178
01:08:01,240 --> 01:08:05,342
deterministically
in polynomial space.

1179
01:08:05,342 --> 01:08:07,050
But this time, it's
going to be n squared

1180
01:08:07,050 --> 01:08:09,120
space instead of
nondeterministically

1181
01:08:09,120 --> 01:08:10,290
in n space.

1182
01:08:10,290 --> 01:08:11,760
So there's going
to be some cost,

1183
01:08:11,760 --> 01:08:15,040
but it's only going
to be a squaring.

1184
01:08:15,040 --> 01:08:17,140
So remember what the problem is.

1185
01:08:17,140 --> 01:08:19,510
I'm giving you
that DFA, and I've

1186
01:08:19,510 --> 01:08:22,300
given you two strings in
the language of that DFA.

1187
01:08:22,300 --> 01:08:26,830
And I want to know, can I
get from the first string

1188
01:08:26,830 --> 01:08:29,979
to the second string by
changing one symbol at a time,

1189
01:08:29,979 --> 01:08:35,200
but always making sure that
the strings along the way

1190
01:08:35,200 --> 01:08:36,505
are accepted by that DFA?

1191
01:08:40,200 --> 01:08:42,990
So I'm going to introduce
notation saying,

1192
01:08:42,990 --> 01:08:45,960
can I get from string
u to v by a ladder?

1193
01:08:45,960 --> 01:08:48,990
But now I'm limiting how
many steps I can take.

1194
01:08:48,990 --> 01:08:51,840
So I'm writing u to
v, but doing it only

1195
01:08:51,840 --> 01:08:55,560
within B intermediate
strings, B steps.

1196
01:08:55,560 --> 01:08:58,590
So is there a ladder from
u to v of length at most B?

1197
01:08:58,590 --> 01:09:01,080
That's what it means to
write this notation down.

1198
01:09:03,680 --> 01:09:07,069
So I'm going to give you
a recursive procedure

1199
01:09:07,069 --> 01:09:10,609
to solve the bounded ladder
problem, where it's just

1200
01:09:10,609 --> 01:09:13,819
like before, but now
I'm going to say,

1201
01:09:13,819 --> 01:09:15,859
not only does there
a ladder from u to v,

1202
01:09:15,859 --> 01:09:23,020
but there's a ladder
of length at most B.

1203
01:09:23,020 --> 01:09:25,840
And that's going to allow
me to solve the ladder

1204
01:09:25,840 --> 01:09:38,760
problem recursively by
shrinking the size of B.

1205
01:09:38,760 --> 01:09:42,479
So how is this going to work?

1206
01:09:47,540 --> 01:09:49,229
Here is going to be the idea.

1207
01:09:49,229 --> 01:09:55,430
So here's my u and my
v. And the procedure

1208
01:09:55,430 --> 01:10:00,770
is going to work by instead of
nondeterministically guessing

1209
01:10:00,770 --> 01:10:03,230
the steps that take
me from work to play,

1210
01:10:03,230 --> 01:10:05,150
because I don't have
nondeterminism anymore,

1211
01:10:05,150 --> 01:10:07,280
I have to operate
deterministically.

1212
01:10:07,280 --> 01:10:10,145
What I'm going to do is work--

1213
01:10:13,810 --> 01:10:15,140
instead of going from--

1214
01:10:15,140 --> 01:10:19,880
looking at the very first
thing that follows from u,

1215
01:10:19,880 --> 01:10:22,510
I'm going to jump
right to the middle

1216
01:10:22,510 --> 01:10:25,075
and try every possible
middle string.

1217
01:10:28,668 --> 01:10:31,210
I have no clue even what that
middle string should look like,

1218
01:10:31,210 --> 01:10:33,945
so I'm going to try all
possibilities in sequence.

1219
01:10:37,360 --> 01:10:39,220
Once I have one of
those possibilities,

1220
01:10:39,220 --> 01:10:41,380
I'm going to
recursively try to solve

1221
01:10:41,380 --> 01:10:43,690
the problem by splitting that.

1222
01:10:43,690 --> 01:10:48,190
But I'm now going to divide
that B value in half.

1223
01:10:48,190 --> 01:10:50,710
So here is the maximum
value we can have.

1224
01:10:50,710 --> 01:10:52,430
This is the t from
the previous slide

1225
01:10:52,430 --> 01:10:53,605
which is the maximum length.

1226
01:10:57,790 --> 01:11:01,210
Here, I'm going to try
every possible intermediate.

1227
01:11:01,210 --> 01:11:05,530
Let's start off with A, all A's.

1228
01:11:05,530 --> 01:11:07,990
And now I can cut
the problem in half.

1229
01:11:07,990 --> 01:11:11,368
Can I get from work to all
A's and all A's to play?

1230
01:11:11,368 --> 01:11:12,910
Well, very first
thing I should check

1231
01:11:12,910 --> 01:11:15,700
is making sure that
all A's in fact

1232
01:11:15,700 --> 01:11:18,100
is a string in the language.

1233
01:11:18,100 --> 01:11:20,792
And if we're thinking
of the language as--

1234
01:11:20,792 --> 01:11:22,240
imagining it's like English--

1235
01:11:22,240 --> 01:11:24,940
all A's is not a
legitimate word.

1236
01:11:24,940 --> 01:11:27,532
So you try the next one, AAB.

1237
01:11:27,532 --> 01:11:28,990
And this is how
it's going to work,

1238
01:11:28,990 --> 01:11:31,210
but now you're going to be--
instead of using English,

1239
01:11:31,210 --> 01:11:33,293
you're going to feed it
into the finite automaton,

1240
01:11:33,293 --> 01:11:37,290
just one after the next, trying
every possibility until--

1241
01:11:37,290 --> 01:11:42,470
like a clock, like an
odometer, just trying them all,

1242
01:11:42,470 --> 01:11:47,060
until eventually you find a
string that's in the language.

1243
01:11:47,060 --> 01:11:49,760
I'm representing that by
an English word "able."

1244
01:11:49,760 --> 01:11:52,460
Maybe that's the first word
that you would have found.

1245
01:11:52,460 --> 01:11:55,190
And then once you find
that, you're going to--

1246
01:11:55,190 --> 01:11:57,890
can I get from "work"
to "able" and "able"

1247
01:11:57,890 --> 01:12:03,100
to "play" recursively, reusing
the space again, but now

1248
01:12:03,100 --> 01:12:06,390
where the bound is cut in half?

1249
01:12:06,390 --> 01:12:08,680
So that's the whole algorithm.

1250
01:12:08,680 --> 01:12:12,890
So just going
through it quickly,

1251
01:12:12,890 --> 01:12:21,500
and I will do this again,
here is my DFA going from u

1252
01:12:21,500 --> 01:12:23,490
to v within B steps.

1253
01:12:23,490 --> 01:12:27,090
First of all-- oh, this is bad.

1254
01:12:27,090 --> 01:12:28,160
t should not be 1.

1255
01:12:28,160 --> 01:12:31,530
This should be B. If B is 1--

1256
01:12:31,530 --> 01:12:33,890
let me quickly fix that.

1257
01:12:33,890 --> 01:12:36,230
So these t's should be B's.

1258
01:12:36,230 --> 01:12:37,160
My apologies.

1259
01:12:40,070 --> 01:12:41,940
So if t is 1--

1260
01:12:41,940 --> 01:12:44,640
if B is 1, then
they have to-- then

1261
01:12:44,640 --> 01:12:47,480
I'm only allowed a
ladder of length 1.

1262
01:12:47,480 --> 01:12:49,550
Now I just check
intermediate directly.

1263
01:12:49,550 --> 01:12:53,990
Do u and v differ in
just-- in one place?

1264
01:12:53,990 --> 01:12:57,530
If yes, then I accept,
else, I reject.

1265
01:12:57,530 --> 01:12:59,690
If it's greater than
1, now I'm going

1266
01:12:59,690 --> 01:13:01,760
to do this procedure
that I described.

1267
01:13:01,760 --> 01:13:09,600
I'm going to try for each
possible w in the middle,

1268
01:13:09,600 --> 01:13:15,770
I'm going to try that
w, test whether I

1269
01:13:15,770 --> 01:13:19,100
can get from u to w in half
the number of steps and from w

1270
01:13:19,100 --> 01:13:20,720
to v in half the
number of steps,

1271
01:13:20,720 --> 01:13:23,750
and accept if they both accept.

1272
01:13:23,750 --> 01:13:27,890
And if trying all
possible w's, none of them

1273
01:13:27,890 --> 01:13:29,570
work, then I know
that there's no way

1274
01:13:29,570 --> 01:13:31,670
to get from u to v in B steps.

1275
01:13:31,670 --> 01:13:34,130
And so then I reject.

1276
01:13:34,130 --> 01:13:38,060
And then to do the original
problem, which was not

1277
01:13:38,060 --> 01:13:43,490
the bounded ladder problem, I
do the bounded ladder problem

1278
01:13:43,490 --> 01:13:46,730
where I put in t, which is the
maximum possible length that it

1279
01:13:46,730 --> 01:13:51,250
could be to get from work to
play or to get from u to v.

1280
01:13:51,250 --> 01:13:54,660
So the space analysis--

1281
01:13:54,660 --> 01:13:56,160
well, I'm kind of
out of time, here.

1282
01:13:56,160 --> 01:13:58,243
So we're going to go through
this again next time.

1283
01:14:01,210 --> 01:14:03,510
So let me skip that analysis.

1284
01:14:03,510 --> 01:14:05,040
I'll review this next time.

1285
01:14:05,040 --> 01:14:06,360
I have a very quick Check-in.

1286
01:14:06,360 --> 01:14:09,660
I just want to get here.

1287
01:14:09,660 --> 01:14:14,400
Find an English word ladder
that connects the word "must"

1288
01:14:14,400 --> 01:14:17,480
to the word "vote."

1289
01:14:17,480 --> 01:14:18,740
You can think about that.

1290
01:14:18,740 --> 01:14:21,410
I mean, it's not that hard
to come up with such a word

1291
01:14:21,410 --> 01:14:25,220
letter, so I encourage you
to think about that-- also,

1292
01:14:25,220 --> 01:14:28,550
to think about voting,
which is also important.

1293
01:14:28,550 --> 01:14:29,390
That's coming up.

1294
01:14:36,850 --> 01:14:38,320
Another 5 seconds here.

1295
01:14:43,892 --> 01:14:45,350
I'm going to end
this, so make sure

1296
01:14:45,350 --> 01:14:47,240
you get your credit
for the Check-in.

1297
01:14:52,860 --> 01:14:54,825
So we're at the
end of the hour--

1298
01:14:58,740 --> 01:15:00,990
end of the 80 minutes, anyway.

1299
01:15:00,990 --> 01:15:03,960
So this is what we did today.

1300
01:15:03,960 --> 01:15:09,060
And looks like I ran over by
a minute, so my apologies.

1301
01:15:09,060 --> 01:15:11,520
But I'll stick around
here if any of you

1302
01:15:11,520 --> 01:15:12,840
have any further questions.

1303
01:15:12,840 --> 01:15:16,170
But otherwise, lecture is over.

1304
01:15:16,170 --> 01:15:17,580
See you guys.

1305
01:15:17,580 --> 01:15:20,710
Do we know anything about ladder
for other kinds of languages?

1306
01:15:20,710 --> 01:15:24,070
I don't know.

1307
01:15:24,070 --> 01:15:26,010
Interesting
question, whether you

1308
01:15:26,010 --> 01:15:32,780
can say some nice things about
the ladder, the ladder problem,

1309
01:15:32,780 --> 01:15:33,920
in other cases.

1310
01:15:33,920 --> 01:15:36,260
I don't know.

1311
01:15:36,260 --> 01:15:40,700
Why is t here, this value of t?

1312
01:15:40,700 --> 01:15:48,200
Sigma to the m, the maximum
length of a word ladder.

1313
01:15:48,200 --> 01:15:49,473
First of all, we have the m.

1314
01:15:49,473 --> 01:15:51,140
Maybe I should have
written this down. m

1315
01:15:51,140 --> 01:15:57,290
is the length of the words.

1316
01:15:57,290 --> 01:16:00,635
Sigma is the alphabet
of the words.

1317
01:16:03,400 --> 01:16:05,500
So the number of
possible different words

1318
01:16:05,500 --> 01:16:07,120
is sigma to the m.

1319
01:16:07,120 --> 01:16:10,540
These are all possible words
that there could possibly be.

1320
01:16:10,540 --> 01:16:15,822
So there's no reason
in the word ladder ever

1321
01:16:15,822 --> 01:16:18,280
to repeat the word because you
can just find a shorter word

1322
01:16:18,280 --> 01:16:22,510
ladder that still does
the job of connecting

1323
01:16:22,510 --> 01:16:25,360
a start and the end,
because you can just cut out

1324
01:16:25,360 --> 01:16:29,890
that middle part,
the repeated part.

1325
01:16:29,890 --> 01:16:35,490
So in that case, the
longest possible word

1326
01:16:35,490 --> 01:16:38,602
ladder is going to be the
total number of possible words

1327
01:16:38,602 --> 01:16:40,560
that you can have, which
is going to be sigma--

1328
01:16:40,560 --> 01:16:43,680
the size of sigma to the m.

1329
01:16:43,680 --> 01:16:46,240
Explain again why coNP
is a subset of PSPACE.

1330
01:16:51,940 --> 01:16:56,830
Well, maybe I'll
say it this way.

1331
01:16:56,830 --> 01:17:00,670
Why is it every coNP
language also in PSPACE?

1332
01:17:00,670 --> 01:17:03,220
Well, take the complement
of your coNP language.

1333
01:17:03,220 --> 01:17:05,140
That's an NP language.

1334
01:17:05,140 --> 01:17:07,613
An NP language is in PSPACE
because we proved that.

1335
01:17:07,613 --> 01:17:08,530
That's what we proved.

1336
01:17:11,820 --> 01:17:14,580
But if a language is in
PSPACE, its complement

1337
01:17:14,580 --> 01:17:18,360
is also in PSPACE, because
for a deterministic procedure,

1338
01:17:18,360 --> 01:17:20,205
you can just flip the
answer of the machine.

1339
01:17:24,510 --> 01:17:29,520
So if B, language B, is in coNP,
its complement, B complement,

1340
01:17:29,520 --> 01:17:32,670
is in NP, which is in PSPACE.

1341
01:17:32,670 --> 01:17:34,320
So B complement is in PSPACE.

1342
01:17:34,320 --> 01:17:37,740
So now PSPACE-- you
can invert the answer.

1343
01:17:37,740 --> 01:17:40,090
And now B is also in PSPACE.

1344
01:17:40,090 --> 01:17:43,110
I hope that helps.

1345
01:17:43,110 --> 01:17:48,150
Somebody's giving me the answer
to get from "must" to "vote."

1346
01:17:48,150 --> 01:17:51,240
But I've seen that answer.

1347
01:17:51,240 --> 01:17:56,010
There are online tools that
will answer word ladders.

1348
01:17:56,010 --> 01:18:00,922
So you just plug in the
start and the finish,

1349
01:18:00,922 --> 01:18:02,380
and it'll give you
the word ladder.

1350
01:18:02,380 --> 01:18:04,590
And then the one
that this person

1351
01:18:04,590 --> 01:18:07,860
has sent me is the one
you get from that tool,

1352
01:18:07,860 --> 01:18:12,450
so I suspect he didn't
find it himself.

1353
01:18:12,450 --> 01:18:14,730
Before lecture, I actually
solved that on my own,

1354
01:18:14,730 --> 01:18:16,020
besides the one that--

1355
01:18:16,020 --> 01:18:18,810
I know the one that
the tool will give you.

1356
01:18:18,810 --> 01:18:23,040
So that tool gives one
in, I think, five steps.

1357
01:18:23,040 --> 01:18:25,080
And I found one on
my own in six steps.

1358
01:18:25,080 --> 01:18:26,620
It's not that hard.

1359
01:18:26,620 --> 01:18:31,200
Yeah, "must," "most,"
"lost," "lose,"

1360
01:18:31,200 --> 01:18:34,340
"rose," "rote," and "vote."

1361
01:18:34,340 --> 01:18:37,610
So they made that seven steps.

1362
01:18:37,610 --> 01:18:41,585
Anyway, for short words, you
can solve these generally

1363
01:18:41,585 --> 01:18:42,710
pretty quickly on your own.

1364
01:18:45,180 --> 01:18:45,680
What else?

1365
01:18:45,680 --> 01:18:47,240
What else can I do for you?

1366
01:18:52,530 --> 01:18:54,660
Do we need to worry
about coming back

1367
01:18:54,660 --> 01:19:00,447
to a previously visited word on
the construction on this page?

1368
01:19:00,447 --> 01:19:02,280
No, we don't have to
worry about coming back

1369
01:19:02,280 --> 01:19:03,990
to a previously visited word.

1370
01:19:03,990 --> 01:19:05,910
All you need to worry
about is making sure

1371
01:19:05,910 --> 01:19:09,660
that you bound how long
are you going to go for.

1372
01:19:09,660 --> 01:19:15,610
And that's where the previously
visited issue comes in.

1373
01:19:15,610 --> 01:19:24,580
If the word ladder that you
found repeats some word,

1374
01:19:24,580 --> 01:19:26,950
well, then there would have
been a shorter word ladder

1375
01:19:26,950 --> 01:19:28,180
that would have also worked.

1376
01:19:28,180 --> 01:19:35,740
But it still shows that it's
possible to get from the start

1377
01:19:35,740 --> 01:19:41,050
word to the finish word if you
have a repeated one in between.

1378
01:19:41,050 --> 01:19:43,070
So that doesn't matter.

1379
01:19:43,070 --> 01:19:44,740
We don't have to
worry about that.

1380
01:19:44,740 --> 01:19:47,030
If you did, then it
would be problem.

1381
01:19:47,030 --> 01:19:48,590
So I think I will--

1382
01:19:48,590 --> 01:19:49,120
4:05.

1383
01:19:49,120 --> 01:19:51,280
I think I'm going to head out.

1384
01:19:51,280 --> 01:19:52,330
See you all, guys.

1385
01:19:52,330 --> 01:19:55,280
And I'm going to join my
TAs in a meeting shortly.

1386
01:19:55,280 --> 01:19:55,780
So bye-bye.

1387
01:19:55,780 --> 01:19:58,290
Thank you for being here.