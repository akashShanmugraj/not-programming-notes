1
00:00:00,000 --> 00:00:01,980
[SQUEAKING]

2
00:00:01,980 --> 00:00:04,455
[RUSTLING]

3
00:00:04,455 --> 00:00:06,930
[CLICKING]

4
00:00:25,590 --> 00:00:27,340
MICHAEL SIPSER: OK,
welcome everybody.

5
00:00:27,340 --> 00:00:31,680
So we are here today,
lecture number 21.

6
00:00:31,680 --> 00:00:34,770
Coming into the
homestretch of the course.

7
00:00:34,770 --> 00:00:38,850
I'd say probably
this last quarter

8
00:00:38,850 --> 00:00:42,040
of the course is a bit
more technical, perhaps.

9
00:00:42,040 --> 00:00:43,290
So a little bit more abstract.

10
00:00:43,290 --> 00:00:46,620
Some of the theorems are
going to be more difficult.

11
00:00:46,620 --> 00:00:49,740
So I'll try to work through
them slowly and answer

12
00:00:49,740 --> 00:00:50,400
your questions.

13
00:00:50,400 --> 00:00:54,810
But you know, I
think you can expect

14
00:00:54,810 --> 00:00:57,060
to find the material a
bit more challenging.

15
00:00:57,060 --> 00:01:11,140
As we started-- as we started
with this theorem last time,

16
00:01:11,140 --> 00:01:17,440
about nondeterministic log space
being closed under complement.

17
00:01:17,440 --> 00:01:19,410
So NL equals coNL.

18
00:01:19,410 --> 00:01:22,830
We kind of only got about
maybe a third of the way

19
00:01:22,830 --> 00:01:23,440
through that.

20
00:01:23,440 --> 00:01:25,350
So I'm going to
start over with that,

21
00:01:25,350 --> 00:01:28,470
and spend kind of the
first half of the lecture

22
00:01:28,470 --> 00:01:29,800
today talking about that.

23
00:01:29,800 --> 00:01:32,910
And then we're going to
talk about the hierarchy

24
00:01:32,910 --> 00:01:36,660
theorems, which are a
very important aspect

25
00:01:36,660 --> 00:01:38,520
of the complexity landscape.

26
00:01:38,520 --> 00:01:44,780
Basically, they tell you that if
you allow your favorite model,

27
00:01:44,780 --> 00:01:48,510
let's say Turing machines,
to have more resources,

28
00:01:48,510 --> 00:01:50,990
then they can do more things.

29
00:01:50,990 --> 00:01:53,150
But we'll get to
that in due course.

30
00:01:53,150 --> 00:01:58,460
OK, so let us go back to--

31
00:01:58,460 --> 00:02:02,600
oops, reminder to myself--

32
00:02:02,600 --> 00:02:08,400
go back to the
Immerman-SzelepcsÃ©nyi theorem,

33
00:02:08,400 --> 00:02:13,220
which is that NL
is equal to coNL.

34
00:02:13,220 --> 00:02:15,590
So as I mentioned,
these are going

35
00:02:15,590 --> 00:02:18,080
to be the same
slides as last time.

36
00:02:18,080 --> 00:02:21,740
And I'll just try to
walk through them slowly.

37
00:02:21,740 --> 00:02:24,840
I hope you get it.

38
00:02:24,840 --> 00:02:29,450
But if you don't, ask
me or the TAs questions.

39
00:02:29,450 --> 00:02:35,870
So we're going to first, I mean,
the thing we're going to show

40
00:02:35,870 --> 00:02:39,020
is that the
complement of path is

41
00:02:39,020 --> 00:02:41,960
solvable in
non-deterministic log space.

42
00:02:41,960 --> 00:02:45,770
We already know that
path is solvable in NL.

43
00:02:45,770 --> 00:02:47,090
That's easy to do.

44
00:02:47,090 --> 00:02:50,780
You basically just
start at the start node,

45
00:02:50,780 --> 00:02:53,030
and you guess the
sequence of nodes,

46
00:02:53,030 --> 00:02:57,000
storing only the current node in
your log space working memory,

47
00:02:57,000 --> 00:03:00,920
on your logs based work tape.

48
00:03:00,920 --> 00:03:03,800
You guess the sequence of
nodes on the different branches

49
00:03:03,800 --> 00:03:05,090
of the non-determinism.

50
00:03:05,090 --> 00:03:07,550
And if you ever get
to the target node t,

51
00:03:07,550 --> 00:03:09,530
then you can accept.

52
00:03:09,530 --> 00:03:12,920
But how can a non-deterministic
log space machine

53
00:03:12,920 --> 00:03:16,100
know or accept the
complement of path?

54
00:03:16,100 --> 00:03:19,670
So it would have to accept
when there's no path.

55
00:03:19,670 --> 00:03:23,240
And that is a lot harder.

56
00:03:23,240 --> 00:03:27,140
But big surprise to the
complexity community

57
00:03:27,140 --> 00:03:28,580
that it is true.

58
00:03:31,350 --> 00:03:34,190
So as we discussed
last time, we're

59
00:03:34,190 --> 00:03:37,400
going to talk about
computing functions

60
00:03:37,400 --> 00:03:39,290
with a non-deterministic
machine.

61
00:03:39,290 --> 00:03:41,090
And that turns out to
be a convenient way

62
00:03:41,090 --> 00:03:44,250
of looking at this.

63
00:03:44,250 --> 00:03:47,330
So we're going to have
non-deterministic machines that

64
00:03:47,330 --> 00:03:50,840
have different branches of the
non-determinism on some input,

65
00:03:50,840 --> 00:03:53,660
and it's supposed to
compute some function value

66
00:03:53,660 --> 00:03:55,400
remaining on the tape.

67
00:03:55,400 --> 00:03:57,140
But because of the
non-determinism,

68
00:03:57,140 --> 00:03:59,840
you can imagine that
different branches might have

69
00:03:59,840 --> 00:04:01,460
different function outputs.

70
00:04:01,460 --> 00:04:02,900
Well, that's not allowed.

71
00:04:02,900 --> 00:04:09,330
All branches must either report
the value of the function

72
00:04:09,330 --> 00:04:12,900
that we're trying to
compute, or they can punt.

73
00:04:12,900 --> 00:04:20,310
Basically, they can reject
and say, well, basically I

74
00:04:20,310 --> 00:04:22,019
don't know.

75
00:04:22,019 --> 00:04:25,260
So all branches must either
report the correct answer,

76
00:04:25,260 --> 00:04:26,780
or they can say I don't know.

77
00:04:26,780 --> 00:04:28,610
And some branch must--

78
00:04:28,610 --> 00:04:31,440
at least one branch
must report an answer.

79
00:04:31,440 --> 00:04:34,630
Must report the answer.

80
00:04:34,630 --> 00:04:37,090
And that's what it
means to be computing

81
00:04:37,090 --> 00:04:40,820
a function with a
non-deterministic machine.

82
00:04:40,820 --> 00:04:43,740
And we're going to show
that certain functions can

83
00:04:43,740 --> 00:04:46,165
be computed with
nondeterministic log space

84
00:04:46,165 --> 00:04:46,665
machines.

85
00:04:49,880 --> 00:04:52,850
In particular,
this path function,

86
00:04:52,850 --> 00:04:56,600
which sort of incorporates
both the positive and negative

87
00:04:56,600 --> 00:04:59,990
of both when there is a
path and when there is not

88
00:04:59,990 --> 00:05:02,960
a path into the function,
because the function

89
00:05:02,960 --> 00:05:07,700
has to answer yes when there is
a path from s to t and no when

90
00:05:07,700 --> 00:05:11,090
there is no path from s to t.

91
00:05:11,090 --> 00:05:16,950
So if you could do
this, you're done.

92
00:05:16,950 --> 00:05:20,310
Because you can make
a non-deterministic--

93
00:05:20,310 --> 00:05:23,440
you can make an NL machine.

94
00:05:23,440 --> 00:05:25,350
So if you could compute
the path function,

95
00:05:25,350 --> 00:05:28,440
you can make an NL
machine, which would accept

96
00:05:28,440 --> 00:05:30,060
whenever the function says no.

97
00:05:33,400 --> 00:05:39,430
And the other cases, and
if the machine that's

98
00:05:39,430 --> 00:05:44,140
computing the function rejects,
then you'll reject as well.

99
00:05:44,140 --> 00:05:46,240
But you accept if
the function says no.

100
00:05:46,240 --> 00:05:47,740
And so therefore,
you're going to be

101
00:05:47,740 --> 00:05:51,250
making an NL machine which
does the complement of the path

102
00:05:51,250 --> 00:05:53,560
problem.

103
00:05:53,560 --> 00:06:00,010
So if you can compute the path
function, that would be great.

104
00:06:00,010 --> 00:06:01,960
So that's what we would
like to be able to do.

105
00:06:04,600 --> 00:06:08,560
So as I mentioned, we're going
to have two other values that

106
00:06:08,560 --> 00:06:11,080
are going to be relevant
to computing the path

107
00:06:11,080 --> 00:06:13,390
function, which is what
we're ultimately going to do.

108
00:06:13,390 --> 00:06:16,030
And that's going to
be the number of nodes

109
00:06:16,030 --> 00:06:20,140
that you can reach
from the start,

110
00:06:20,140 --> 00:06:24,820
from the start node in
your graph, and the--

111
00:06:24,820 --> 00:06:27,590
for-- R is the
collection of nodes and c

112
00:06:27,590 --> 00:06:29,410
is the number of
reachable nodes.

113
00:06:32,130 --> 00:06:33,220
So shown on this picture.

114
00:06:33,220 --> 00:06:37,230
And here, if it's helpful to
you to see it in a more formal

115
00:06:37,230 --> 00:06:40,760
[INAUDIBLE] is
you can think of R

116
00:06:40,760 --> 00:06:44,090
as a function of the graph
and the start node, of course.

117
00:06:44,090 --> 00:06:45,890
But sometimes we'll
just call it R,

118
00:06:45,890 --> 00:06:49,400
when it's clear which graph and
start node we're talking about.

119
00:06:52,860 --> 00:06:55,250
R is the set of reachable nodes.

120
00:06:55,250 --> 00:07:01,890
So it's the collection u
such that the answer is yes.

121
00:07:01,890 --> 00:07:13,830
And c is the size of R. So
the way we're going to start

122
00:07:13,830 --> 00:07:18,120
is kind of an easy theorem,
though this is still

123
00:07:18,120 --> 00:07:21,070
going to be relevant
kind of at the end.

124
00:07:21,070 --> 00:07:25,590
But for now, it's really more
a practice with the concept

125
00:07:25,590 --> 00:07:28,200
that we have come up, you
know, this function concept

126
00:07:28,200 --> 00:07:30,070
that we've just introduced.

127
00:07:30,070 --> 00:07:36,300
So I want to say that the path
function, with an NL machine.

128
00:07:36,300 --> 00:07:41,640
Then I can compute the
count with an NL machine.

129
00:07:41,640 --> 00:07:45,240
So understand what a computing
the path function means.

130
00:07:45,240 --> 00:07:51,500
That you have your NL
machine, and every branch

131
00:07:51,500 --> 00:07:54,560
has to either say I don't
know, which is reject.

132
00:07:54,560 --> 00:07:57,972
Or it has to have
the answer, which

133
00:07:57,972 --> 00:07:59,930
it's going to be yes if
there is a path, and no

134
00:07:59,930 --> 00:08:00,860
if there is no path.

135
00:08:04,150 --> 00:08:10,200
And if I can be able to count
the number of nodes that do

136
00:08:10,200 --> 00:08:11,520
have a path.

137
00:08:11,520 --> 00:08:13,545
The number of nodes for
which the answer is yes.

138
00:08:17,270 --> 00:08:19,760
And this, I think if
you're comfortable

139
00:08:19,760 --> 00:08:25,700
with the definition, this
is more or less obvious,

140
00:08:25,700 --> 00:08:28,520
because what you
would do is you would

141
00:08:28,520 --> 00:08:31,790
go through the nodes
of G, one by one,

142
00:08:31,790 --> 00:08:39,990
and test using your path
function what the answer is.

143
00:08:39,990 --> 00:08:41,370
Yes or a no.

144
00:08:41,370 --> 00:08:44,580
And every time it's a yes,
you add 1 to the count.

145
00:08:44,580 --> 00:08:47,340
Until you've gone
through all of the nodes.

146
00:08:47,340 --> 00:08:50,770
And then you have your
answer, which is [INAUDIBLE]

147
00:08:50,770 --> 00:08:53,910
and that's c.

148
00:08:53,910 --> 00:08:57,360
Now, if the machine
that's trying

149
00:08:57,360 --> 00:09:01,930
to compute the path function
on the non-determinism rejects,

150
00:09:01,930 --> 00:09:02,590
that's OK.

151
00:09:02,590 --> 00:09:07,180
For computing c, that
branch will reject also.

152
00:09:07,180 --> 00:09:11,650
But when you're-- some branch
has to get the right answer

153
00:09:11,650 --> 00:09:14,140
on--

154
00:09:14,140 --> 00:09:17,120
has to get the right answer.

155
00:09:17,120 --> 00:09:20,865
And so then, you get the--

156
00:09:20,865 --> 00:09:23,650
you know what's
happening with that node.

157
00:09:23,650 --> 00:09:27,610
And so you then can either
increment the count,

158
00:09:27,610 --> 00:09:29,320
or you move on to the next node.

159
00:09:29,320 --> 00:09:32,442
I think I'm trying to say--

160
00:09:32,442 --> 00:09:34,150
I'm not sure if I'm
making it any clearer

161
00:09:34,150 --> 00:09:35,560
by kind of repeating myself.

162
00:09:35,560 --> 00:09:36,890
But OK, here.

163
00:09:36,890 --> 00:09:38,890
So you're going to start
out with-- you're given

164
00:09:38,890 --> 00:09:42,110
the graph and the start node.

165
00:09:42,110 --> 00:09:44,570
We're trying to compute this
value c, which is the number

166
00:09:44,570 --> 00:09:46,862
reachable from the start node.

167
00:09:46,862 --> 00:09:49,070
You start out with-- you
have a counter, which you're

168
00:09:49,070 --> 00:09:50,720
going to set initially to 0.

169
00:09:50,720 --> 00:09:53,460
And you go through
every node of the graph.

170
00:09:53,460 --> 00:09:59,130
And if the path
function computation

171
00:09:59,130 --> 00:10:02,145
says yes, you can reach u,
then you add 1 to the count.

172
00:10:02,145 --> 00:10:07,290
It says no, you cannot reach
u, then you just continue.

173
00:10:07,290 --> 00:10:10,440
And maybe I should
add another line here.

174
00:10:10,440 --> 00:10:19,230
If the thing that's computing
rejects, then you also reject.

175
00:10:19,230 --> 00:10:20,790
And then at the
end, you output--

176
00:10:24,290 --> 00:10:27,100
so what we're going to prove
is the other direction.

177
00:10:27,100 --> 00:10:31,600
If I give you the count, then
I can answer the question

178
00:10:31,600 --> 00:10:34,310
for each node whether
it's reachable or not.

179
00:10:34,310 --> 00:10:35,740
And this is the thing.

180
00:10:35,740 --> 00:10:38,470
Because what it's saying that
is I can give you the count,

181
00:10:38,470 --> 00:10:40,850
I'm done.

182
00:10:40,850 --> 00:10:43,280
If we can get that count,
that's going to be enough.

183
00:10:47,600 --> 00:10:50,065
So maybe even before
the check, and maybe we

184
00:10:50,065 --> 00:10:51,440
should just answer
any questions.

185
00:10:51,440 --> 00:10:57,620
Because if you're stuck
here, then you're doomed.

186
00:10:57,620 --> 00:11:00,740
So I think it makes sense
to try to understand

187
00:11:00,740 --> 00:11:03,690
what's going on at this--

188
00:11:03,690 --> 00:11:07,020
because I think the
real guts of this proof

189
00:11:07,020 --> 00:11:09,510
is coming on the next slide.

190
00:11:09,510 --> 00:11:11,860
Kind of the main idea.

191
00:11:11,860 --> 00:11:15,570
So I'm happy to take, if there's
any questions about this.

192
00:11:21,742 --> 00:11:23,200
I'll just wait for
a second and see

193
00:11:23,200 --> 00:11:24,490
if you're typing away there.

194
00:11:28,017 --> 00:11:29,600
Well, why don't we
go to the check in.

195
00:11:29,600 --> 00:11:31,970
Maybe that'll help.

196
00:11:31,970 --> 00:11:33,380
Not a very difficult check in.

197
00:11:38,510 --> 00:11:40,450
It'll come up.

198
00:11:40,450 --> 00:11:42,160
OK.

199
00:11:42,160 --> 00:11:44,380
Just a little practice
with the concept.

200
00:11:44,380 --> 00:11:47,470
So I'm going to
give you some graph.

201
00:11:47,470 --> 00:11:50,380
It has 9 nodes.

202
00:11:50,380 --> 00:11:54,370
And I want to know the
value of the count.

203
00:11:54,370 --> 00:11:58,480
So we'll assume that
s, the start node here,

204
00:11:58,480 --> 00:12:00,760
is reachable from itself.

205
00:12:00,760 --> 00:12:02,010
And now what's the value of c?

206
00:12:07,410 --> 00:12:10,130
Are we good?

207
00:12:10,130 --> 00:12:12,980
I'm going to shut this down,
give you another two seconds.

208
00:12:12,980 --> 00:12:15,530
Please get your answer in.

209
00:12:15,530 --> 00:12:18,245
OK, ready, set, end.

210
00:12:22,690 --> 00:12:26,440
Yeah, the right answer is,
in fact, E, which is 6.

211
00:12:26,440 --> 00:12:29,373
There is 6 reachable
nodes in this graph.

212
00:12:29,373 --> 00:12:31,540
And that's what the value
C is supposed to tell you,

213
00:12:31,540 --> 00:12:34,240
is how many nodes
can I get to from s.

214
00:12:34,240 --> 00:12:39,620
And what I'm saying is that
if I can calculate that

215
00:12:39,620 --> 00:12:41,570
in this sort of
non-deterministic function

216
00:12:41,570 --> 00:12:47,640
sense, so if some branches
can get that answer,

217
00:12:47,640 --> 00:12:53,400
then I can use that to test
for each node, whether it's

218
00:12:53,400 --> 00:12:56,700
reachable or not, which is kind
of a little bit of a miracle.

219
00:12:56,700 --> 00:12:57,870
That's kind of surprising.

220
00:12:57,870 --> 00:13:01,080
Just knowing how many nodes are
reachable will allow me to test

221
00:13:01,080 --> 00:13:05,670
whether each individual node
is reachable, because that's--

222
00:13:05,670 --> 00:13:08,130
no obvious reason
why that would be.

223
00:13:08,130 --> 00:13:10,955
So there's going to be a
procedure for doing that,

224
00:13:10,955 --> 00:13:12,080
which is on the next slide.

225
00:13:12,080 --> 00:13:12,900
And here it is.

226
00:13:16,370 --> 00:13:21,260
So this is the key idea that
we're going to repeat later.

227
00:13:21,260 --> 00:13:25,670
But so it's good to understand.

228
00:13:25,670 --> 00:13:28,220
This is the slide you
really need to understand.

229
00:13:30,980 --> 00:13:32,102
So I'm giving the graph.

230
00:13:32,102 --> 00:13:33,560
Let's assume the
graph has m nodes.

231
00:13:36,590 --> 00:13:38,810
Now, as I said.

232
00:13:38,810 --> 00:13:41,150
OK, so let's just say,
what are we doing here?

233
00:13:41,150 --> 00:13:46,040
Given that count,
we can compute path.

234
00:13:46,040 --> 00:13:49,490
So we'll get the answer for
every node in the graph,

235
00:13:49,490 --> 00:13:51,850
if I just know how many--

236
00:13:51,850 --> 00:13:53,590
so I'll know, I
can get the answer

237
00:13:53,590 --> 00:13:57,900
for whether a node is reachable
or not if I just have--

238
00:13:57,900 --> 00:14:02,010
if I just know how many
reachable nodes there are.

239
00:14:02,010 --> 00:14:05,520
So what I'm going to do is
get that count of how many

240
00:14:05,520 --> 00:14:07,840
are reachable.

241
00:14:07,840 --> 00:14:10,410
Now, I'm going to go to--

242
00:14:10,410 --> 00:14:11,850
I'm going-- so look.

243
00:14:11,850 --> 00:14:14,490
Let's see, what's the
idea here, before we even

244
00:14:14,490 --> 00:14:17,630
jump into the algorithm.

245
00:14:17,630 --> 00:14:23,830
The idea is let's say I know
how many nodes are reachable,

246
00:14:23,830 --> 00:14:26,520
like 100 nodes are reachable.

247
00:14:26,520 --> 00:14:28,760
Now, what I'm going to
do, what the algorithm

248
00:14:28,760 --> 00:14:33,250
that is going to do is find
all 100 reachable nodes.

249
00:14:33,250 --> 00:14:35,110
[? Go ?] 1 by 1, but
it doesn't matter.

250
00:14:35,110 --> 00:14:40,450
Sort of conceptually, it's going
to find all reachable nodes.

251
00:14:40,450 --> 00:14:42,810
And non-deterministically
guessing them.

252
00:14:42,810 --> 00:14:44,810
So it's not sure in advance
which ones they are.

253
00:14:44,810 --> 00:14:47,410
But it's going to
guess basically 100--

254
00:14:47,410 --> 00:14:50,355
it's going to guess some of
the nodes as being reachable,

255
00:14:50,355 --> 00:14:52,480
confirm that the ones that
it guesses are reachable

256
00:14:52,480 --> 00:14:54,730
are reachable, and
then check to see

257
00:14:54,730 --> 00:14:57,810
that that number equals 100.

258
00:14:57,810 --> 00:15:00,030
On some branch of
the non-determinism,

259
00:15:00,030 --> 00:15:02,430
you will guess right,
and you'll end up

260
00:15:02,430 --> 00:15:06,540
with exactly the right set
of 100 reachable nodes.

261
00:15:06,540 --> 00:15:11,640
And then you'll see, is t
one of those reachable ones?

262
00:15:11,640 --> 00:15:13,080
In which case you say yes.

263
00:15:13,080 --> 00:15:17,430
Or is t not one of
those 100 nodes.

264
00:15:17,430 --> 00:15:20,610
And then you know
the answer is no.

265
00:15:20,610 --> 00:15:23,190
Because if you've
guessed 100 nodes,

266
00:15:23,190 --> 00:15:25,170
and you know they're
all reachable,

267
00:15:25,170 --> 00:15:27,540
and you know there are
exactly 100 reachable nodes,

268
00:15:27,540 --> 00:15:29,907
then every other node
is not reachable.

269
00:15:33,490 --> 00:15:34,780
So that's the spirit of this.

270
00:15:34,780 --> 00:15:36,447
And that's, I'm just
going to write that

271
00:15:36,447 --> 00:15:40,500
down here in the algorithm.

272
00:15:40,500 --> 00:15:42,420
Can you guys hear me still?

273
00:15:42,420 --> 00:15:45,660
Yeah, somebody said my
audio is like flipping out.

274
00:15:45,660 --> 00:15:50,610
I am getting a sign or
two of unstable internet.

275
00:15:50,610 --> 00:15:54,090
So if you need me to repeat
anything, just send me a note.

276
00:15:54,090 --> 00:15:54,930
Good, thank you.

277
00:16:01,200 --> 00:16:04,860
All right, so well, maybe
I should speak slowly,

278
00:16:04,860 --> 00:16:07,500
if it's not coming
through too well.

279
00:16:13,610 --> 00:16:17,210
So what we're going to do
is go through all the nodes

280
00:16:17,210 --> 00:16:21,730
of the graph, one
by one, and guess

281
00:16:21,730 --> 00:16:25,710
whether it's a reachable
node or not a reachable node.

282
00:16:25,710 --> 00:16:28,110
If we guess it is
reachable, I'm going

283
00:16:28,110 --> 00:16:34,480
to also guess the path, which
shows that it's reachable.

284
00:16:34,480 --> 00:16:36,580
And then I'm going
to-- and I'm going

285
00:16:36,580 --> 00:16:39,160
to keep a count of how many
reachable nodes I found.

286
00:16:42,080 --> 00:16:48,550
If that count agrees with the
value c I started with, then

287
00:16:48,550 --> 00:16:52,020
I know I found them all.

288
00:16:52,020 --> 00:16:57,780
And if t is not one of them,
then I know t is not reachable.

289
00:16:57,780 --> 00:17:00,580
That's the idea.

290
00:17:00,580 --> 00:17:03,010
So here's my--
this is going to be

291
00:17:03,010 --> 00:17:05,829
a count of the number
of nodes that I

292
00:17:05,829 --> 00:17:08,950
have found which are reachable.

293
00:17:08,950 --> 00:17:10,300
That's k.

294
00:17:10,300 --> 00:17:13,810
Now here I'm going to
non-deterministically choose,

295
00:17:13,810 --> 00:17:16,270
is it a reachable node or not.

296
00:17:16,270 --> 00:17:19,630
I've just called it two
branches of the algorithm, the p

297
00:17:19,630 --> 00:17:22,569
branch or the n branch.
p means there's a path,

298
00:17:22,569 --> 00:17:26,750
an n means there's no path.

299
00:17:26,750 --> 00:17:30,680
So if I guessed p at this
point for this node u--

300
00:17:30,680 --> 00:17:32,740
so I'm going to each of
the nodes one by one.

301
00:17:32,740 --> 00:17:34,690
u is the current node.

302
00:17:34,690 --> 00:17:39,790
If I've guessed that it
does have a path from s,

303
00:17:39,790 --> 00:17:43,300
then I'm going to
guess that path,

304
00:17:43,300 --> 00:17:45,940
to make sure that it
really is a reachable node.

305
00:17:52,280 --> 00:17:55,190
If I fail to find
a path, then this

306
00:17:55,190 --> 00:17:58,670
is one of the branches of
the non-determinism that

307
00:17:58,670 --> 00:18:00,578
is going to fail.

308
00:18:00,578 --> 00:18:01,370
It's going to punt.

309
00:18:01,370 --> 00:18:04,640
It's going to say, I don't
know under this branch.

310
00:18:04,640 --> 00:18:07,910
Because either
you guessed wrong,

311
00:18:07,910 --> 00:18:10,370
and this node was not reachable.

312
00:18:10,370 --> 00:18:13,940
Or if it was
reachable, you failed

313
00:18:13,940 --> 00:18:17,360
to find a path, which shows
you that it's reachable.

314
00:18:17,360 --> 00:18:20,850
There was some path, but you
didn't guess the right one.

315
00:18:20,850 --> 00:18:23,190
Either way, you
made a bad choice.

316
00:18:23,190 --> 00:18:24,870
You're just going to punt.

317
00:18:27,880 --> 00:18:30,430
Now, if you have
determined that t

318
00:18:30,430 --> 00:18:34,540
is that node that
you've just shown

319
00:18:34,540 --> 00:18:37,360
is reachable, because at
this stage, you did not fail,

320
00:18:37,360 --> 00:18:47,350
so you succeeded in
showing a path to u, then--

321
00:18:47,350 --> 00:18:51,460
and u equals t,
then t is reachable,

322
00:18:51,460 --> 00:18:55,470
so there is a path from s
to t, and you're finished.

323
00:18:55,470 --> 00:18:58,240
Because you know, you've got
the answer you're looking for.

324
00:18:58,240 --> 00:19:00,850
And so now you can say yes.

325
00:19:00,850 --> 00:19:03,580
Otherwise, if u is
some other node,

326
00:19:03,580 --> 00:19:05,690
then you can just
increase your count

327
00:19:05,690 --> 00:19:07,690
of the number of reachable
nodes that you found.

328
00:19:10,500 --> 00:19:12,450
So you found a reachable node.

329
00:19:12,450 --> 00:19:14,490
If it's t, you're
great, you're done.

330
00:19:14,490 --> 00:19:17,430
If it's not, you just
include that in your count

331
00:19:17,430 --> 00:19:19,200
of reachable nodes.

332
00:19:19,200 --> 00:19:22,380
Now, if you've guessed that
the node is not reachable, OK,

333
00:19:22,380 --> 00:19:23,700
then you just proceed--

334
00:19:23,700 --> 00:19:26,603
you're not going
to-- you're just

335
00:19:26,603 --> 00:19:28,020
going to move on
to the next node,

336
00:19:28,020 --> 00:19:31,500
because you're looking for a
collection of reachable nodes.

337
00:19:38,493 --> 00:19:39,660
Getting some questions here.

338
00:19:39,660 --> 00:19:42,360
But let me wait
till the end here.

339
00:19:42,360 --> 00:19:47,050
Now, after I finish going
through all of the nodes,

340
00:19:47,050 --> 00:19:51,190
so I'm finished
with this loop here

341
00:19:51,190 --> 00:19:54,340
of going through
all the nodes, now I

342
00:19:54,340 --> 00:19:59,750
see, did I find c
reachable nodes,

343
00:19:59,750 --> 00:20:01,880
because k is the
count of the nodes

344
00:20:01,880 --> 00:20:03,590
that I've found to be reachable.

345
00:20:03,590 --> 00:20:07,310
If that agrees with c, then
I know I found them all.

346
00:20:07,310 --> 00:20:10,910
If a differs from c, then
something has gone wrong.

347
00:20:10,910 --> 00:20:13,370
Because I am told there
are c reachable nodes,

348
00:20:13,370 --> 00:20:16,010
and I did not find
c reachable nodes.

349
00:20:16,010 --> 00:20:17,930
So I made some bad
guesses along the way.

350
00:20:17,930 --> 00:20:20,690
I guessed some node which
really is reachable,

351
00:20:20,690 --> 00:20:21,990
I guess it was not reachable.

352
00:20:21,990 --> 00:20:23,420
So I didn't find them all.

353
00:20:23,420 --> 00:20:25,490
I'm going to punt.

354
00:20:25,490 --> 00:20:31,190
But if I found them all, and
I didn't end up accepting it,

355
00:20:31,190 --> 00:20:33,560
I didn't say yes at
this stage, so t was not

356
00:20:33,560 --> 00:20:35,600
one of the ones I
found unreachable,

357
00:20:35,600 --> 00:20:39,260
then I'm convinced
that t is not one

358
00:20:39,260 --> 00:20:40,550
of those that are reachable.

359
00:20:40,550 --> 00:20:42,110
That was not one
of those c nodes

360
00:20:42,110 --> 00:20:43,485
that I found which
are reachable.

361
00:20:43,485 --> 00:20:46,140
And now, I can say no.

362
00:20:46,140 --> 00:20:52,172
So let me take questions here,
because I think we're, yeah,

363
00:20:52,172 --> 00:20:53,380
that's the end of this slide.

364
00:20:53,380 --> 00:21:00,310
This is kind of an important
piece to understand.

365
00:21:00,310 --> 00:21:02,890
We can spend a couple of minutes
trying to work through this.

366
00:21:06,593 --> 00:21:08,760
So somebody is asking, how
does nondeterministically

367
00:21:08,760 --> 00:21:10,260
pick a path fail?

368
00:21:10,260 --> 00:21:16,620
If you fail, what I mean
is pick a path from s to u.

369
00:21:16,620 --> 00:21:20,040
So you have to go from s to
whatever your current node

370
00:21:20,040 --> 00:21:21,640
u is.

371
00:21:21,640 --> 00:21:24,760
So you're going to
pick some path to u.

372
00:21:24,760 --> 00:21:26,302
You guessed u is reachable.

373
00:21:26,302 --> 00:21:28,510
Now you have to demonstrate
it's reachable by picking

374
00:21:28,510 --> 00:21:29,590
a path from s to u.

375
00:21:29,590 --> 00:21:34,030
If you don't end up
at u, and the pair--

376
00:21:34,030 --> 00:21:36,250
you don't want to go
forever on any branch.

377
00:21:36,250 --> 00:21:38,500
So you're going to
limit it to m steps.

378
00:21:38,500 --> 00:21:41,360
Your path has to be
of length m at most.

379
00:21:41,360 --> 00:21:47,090
So after m steps, if you have
not reached u by that point,

380
00:21:47,090 --> 00:21:49,805
you've picked a bad path,
and you're going to reject.

381
00:22:05,870 --> 00:22:08,602
So what's the difference
between no and reject?

382
00:22:08,602 --> 00:22:09,560
That's a good question.

383
00:22:12,230 --> 00:22:15,740
Reject, in this case,
is an I don't know.

384
00:22:15,740 --> 00:22:19,640
The algorithm could not
make a determination based

385
00:22:19,640 --> 00:22:22,500
on the guesses that it's made.

386
00:22:22,500 --> 00:22:25,110
In this non-deterministic
branch of the algorithm,

387
00:22:25,110 --> 00:22:27,450
it made bad choices,
which doesn't

388
00:22:27,450 --> 00:22:30,690
allow it to reach a conclusion
one way or the other.

389
00:22:33,650 --> 00:22:37,160
Remember, this algorithm here
is computing a function now.

390
00:22:37,160 --> 00:22:38,660
It's not an alg--
it can [INAUDIBLE]

391
00:22:38,660 --> 00:22:41,930
nondeterministic algorithm in
the language recognition sense,

392
00:22:41,930 --> 00:22:43,860
this is a function computer.

393
00:22:43,860 --> 00:22:47,180
And so it has to get the answer
to the path function, which

394
00:22:47,180 --> 00:22:50,845
is a yes or a no, or an I
don't know on some branches.

395
00:22:50,845 --> 00:22:53,770
On some branches it's
allowed to do that too.

396
00:22:53,770 --> 00:22:56,293
So no and reject are
totally different.

397
00:23:03,668 --> 00:23:05,710
This is the same thing we
talked about last time.

398
00:23:05,710 --> 00:23:09,190
Why do we need two
branches for p and n,

399
00:23:09,190 --> 00:23:12,220
if we're only going to
have a proposal just

400
00:23:12,220 --> 00:23:13,720
to have the p branch?

401
00:23:13,720 --> 00:23:17,290
Well, but some nodes
are not reachable.

402
00:23:17,290 --> 00:23:18,910
If you're going to look for--

403
00:23:18,910 --> 00:23:24,940
if you have an unreachable
node, so it's not in R,

404
00:23:24,940 --> 00:23:27,610
you can't get to
that node from s,

405
00:23:27,610 --> 00:23:30,250
you have to skip over
that node, because you're

406
00:23:30,250 --> 00:23:33,760
trying to find a subset
of the reachable nodes.

407
00:23:33,760 --> 00:23:40,530
So you're trying to pick that
subset here one node at a time.

408
00:23:40,530 --> 00:23:42,260
So if you're only
going to allow things--

409
00:23:42,260 --> 00:23:44,330
you're going to require
everything in the subset,

410
00:23:44,330 --> 00:23:46,590
there are going to be some
nodes which are not reachable,

411
00:23:46,590 --> 00:23:48,170
and you're not going to find
a path because they're not

412
00:23:48,170 --> 00:23:50,128
reachable, and you're
going to end up rejecting

413
00:23:50,128 --> 00:23:52,080
all the time on that node.

414
00:23:52,080 --> 00:23:53,310
So you're going to be--

415
00:23:53,310 --> 00:23:56,220
the algorithm will not work.

416
00:23:59,320 --> 00:24:01,610
So I'm not sure I understand
this question here,

417
00:24:01,610 --> 00:24:03,800
but somebody says,
if t is reachable,

418
00:24:03,800 --> 00:24:05,910
we output yes on that branch.

419
00:24:05,910 --> 00:24:11,940
But don't we also output
no on some other branch?

420
00:24:11,940 --> 00:24:14,610
That's a good-- let's
see what happens

421
00:24:14,610 --> 00:24:17,670
if t is actually reachable.

422
00:24:20,330 --> 00:24:22,460
How can we-- so
if t is reachable,

423
00:24:22,460 --> 00:24:24,950
there's some branch that's
going to output yes.

424
00:24:24,950 --> 00:24:26,300
We all agree with that.

425
00:24:26,300 --> 00:24:29,630
Or at least, if you're
following, we agree.

426
00:24:29,630 --> 00:24:33,890
But could some other
branch output no?

427
00:24:33,890 --> 00:24:38,140
If t actually is reachable.

428
00:24:38,140 --> 00:24:41,380
OK, that's a great question.

429
00:24:41,380 --> 00:24:43,540
And no, that's not
going to happen.

430
00:24:46,880 --> 00:24:50,030
If t is actually reachable,
how could a branch output no?

431
00:24:52,630 --> 00:24:56,770
That must mean that
it does not guess t

432
00:24:56,770 --> 00:24:58,630
as one of the reachable nodes.

433
00:24:58,630 --> 00:25:01,660
Because it's going through
all of the nodes here,

434
00:25:01,660 --> 00:25:03,970
you know, it's going
through all the nodes,

435
00:25:03,970 --> 00:25:08,210
and picking them as
reachable or not.

436
00:25:08,210 --> 00:25:10,470
If it picked t as one
of the reasonable ones,

437
00:25:10,470 --> 00:25:12,580
then it's going to output yes.

438
00:25:12,580 --> 00:25:14,620
Because it will
find, it'll either

439
00:25:14,620 --> 00:25:17,500
output yes, or if it
doesn't find the right--

440
00:25:17,500 --> 00:25:19,180
doesn't guess the
right path, it'll

441
00:25:19,180 --> 00:25:21,790
end up rejecting on that path.

442
00:25:21,790 --> 00:25:25,930
But some path will end up saying
yes, so if t is reachable.

443
00:25:25,930 --> 00:25:28,810
And if you guess--

444
00:25:28,810 --> 00:25:31,570
if you know t is reachable,
and you guess t--

445
00:25:31,570 --> 00:25:35,470
you guess u is reachable at
the point when u equals t,

446
00:25:35,470 --> 00:25:37,890
you will end up outputting yes.

447
00:25:37,890 --> 00:25:41,880
The only way you
could not output yes

448
00:25:41,880 --> 00:25:44,910
is if you guessed that
node is unreachable.

449
00:25:48,090 --> 00:25:51,790
But then your count is
not going to add up right.

450
00:25:51,790 --> 00:25:54,820
Because you wouldn't-- you
did not find all the reachable

451
00:25:54,820 --> 00:25:56,260
nodes.

452
00:25:56,260 --> 00:25:58,300
If t is one of the
reachable nodes,

453
00:25:58,300 --> 00:26:00,400
and you know there are
100 reachable nodes,

454
00:26:00,400 --> 00:26:03,040
and you skipped over
t as one of the ones

455
00:26:03,040 --> 00:26:05,320
that you say is
unreachable, you at best

456
00:26:05,320 --> 00:26:07,360
can only find 99
reachable nodes.

457
00:26:07,360 --> 00:26:11,030
And you're not going
to end up saying no.

458
00:26:11,030 --> 00:26:14,502
You're going to
end up rejecting.

459
00:26:14,502 --> 00:26:15,710
So it's a very good question.

460
00:26:15,710 --> 00:26:18,530
But you have to think through
what's going to happen here.

461
00:26:18,530 --> 00:26:22,080
This c here is kind of a check.

462
00:26:22,080 --> 00:26:29,512
It's almost like, well,
it's like a checksum,

463
00:26:29,512 --> 00:26:30,470
if you know what it is.

464
00:26:30,470 --> 00:26:33,125
It makes sure that
everything that--

465
00:26:33,125 --> 00:26:34,730
if you got to c.

466
00:26:34,730 --> 00:26:36,260
If you got to--

467
00:26:36,260 --> 00:26:38,420
if k equals c at
this point, that

468
00:26:38,420 --> 00:26:40,710
means you actually found
all of the reachable nodes.

469
00:26:40,710 --> 00:26:44,615
So c is kind of a check that you
found all the reachable nodes.

470
00:26:49,090 --> 00:26:49,590
Right?

471
00:26:49,590 --> 00:26:52,800
So if k equals c
at this point, you

472
00:26:52,800 --> 00:26:56,785
have found every reachable node.

473
00:26:56,785 --> 00:26:58,660
And t was one of the
ones that are reachable.

474
00:26:58,660 --> 00:26:59,470
You found t.

475
00:27:04,660 --> 00:27:05,395
OK, let's see.

476
00:27:09,070 --> 00:27:11,260
Is the reason we do this
with c essentially so

477
00:27:11,260 --> 00:27:13,210
that we know when we
can stop guessing,

478
00:27:13,210 --> 00:27:16,270
and correctly identify if
it's impossible to reach t?

479
00:27:16,270 --> 00:27:18,070
Well, it's not a matter of--

480
00:27:18,070 --> 00:27:19,870
it's not a matter of
stopping guessing.

481
00:27:19,870 --> 00:27:24,100
It's a check that
we found everything.

482
00:27:24,100 --> 00:27:27,400
Because we're going to go
through and do all the guessing

483
00:27:27,400 --> 00:27:31,290
for every node no matter what.

484
00:27:31,290 --> 00:27:33,800
So we're not going to
stop anything early,

485
00:27:33,800 --> 00:27:35,950
unless we find that
t is reachable.

486
00:27:35,950 --> 00:27:37,250
Then we can stop early.

487
00:27:37,250 --> 00:27:39,723
But to show that t
is not reachable,

488
00:27:39,723 --> 00:27:41,390
we have to go through
the whole process.

489
00:27:46,820 --> 00:27:48,530
How come we intuitively
see that we don't

490
00:27:48,530 --> 00:27:49,850
have contradictory branches?

491
00:27:49,850 --> 00:27:52,510
That's sort of-- I was
trying to say that just now.

492
00:27:52,510 --> 00:27:54,830
I hope that got through.

493
00:27:54,830 --> 00:27:57,050
You can't have
contradictory branches,

494
00:27:57,050 --> 00:27:59,540
because if you got
to this stage here,

495
00:27:59,540 --> 00:28:02,450
you have found all
the reachable nodes.

496
00:28:02,450 --> 00:28:05,120
So at this stage,
if you got to six,

497
00:28:05,120 --> 00:28:07,520
you have made all
correct guesses.

498
00:28:10,260 --> 00:28:11,970
You have found all
the reachable nodes.

499
00:28:11,970 --> 00:28:13,890
You have convinced
yourself that they're all

500
00:28:13,890 --> 00:28:18,810
reachable by guessing
the path to them.

501
00:28:18,810 --> 00:28:21,630
And you've checked that
you have the right number

502
00:28:21,630 --> 00:28:24,550
of reachable nodes,
because it equals c.

503
00:28:24,550 --> 00:28:27,640
So you must have found them all.

504
00:28:27,640 --> 00:28:29,390
So you cannot have a
contradictory answer,

505
00:28:29,390 --> 00:28:31,530
because either t is one of the
ones you found, in which case,

506
00:28:31,530 --> 00:28:33,140
you would have already said yes.

507
00:28:33,140 --> 00:28:37,320
Or otherwise, you found them
all, and t was not one of them.

508
00:28:37,320 --> 00:28:39,950
And so you're going to say
no, you can't have both things

509
00:28:39,950 --> 00:28:40,910
cannot happen.

510
00:28:40,910 --> 00:28:41,600
Let's move on.

511
00:28:44,250 --> 00:28:46,950
So next thing we're going
to do is the next slide

512
00:28:46,950 --> 00:28:50,500
is exactly the
same as this slide.

513
00:28:50,500 --> 00:28:55,870
Except instead of
saying is t reachable,

514
00:28:55,870 --> 00:29:00,490
I want to know is it reachable
within d, within distance d.

515
00:29:05,040 --> 00:29:05,540
OK?

516
00:29:05,540 --> 00:29:07,567
So--

517
00:29:07,567 --> 00:29:09,650
Which is going to mean
exactly the same procedure.

518
00:29:09,650 --> 00:29:21,335
Can I get-- instead of asking
can I get from s to t with

519
00:29:21,335 --> 00:29:22,710
a path of any
length-- of course,

520
00:29:22,710 --> 00:29:24,240
it's going to be
at most length m--

521
00:29:24,240 --> 00:29:26,400
now I want to know, can
I get to from s to t

522
00:29:26,400 --> 00:29:29,530
by a path at most length d.

523
00:29:29,530 --> 00:29:32,920
These are the number of
edges in the path, say.

524
00:29:32,920 --> 00:29:38,360
And that's the same procedure,
because instead of--

525
00:29:38,360 --> 00:29:41,750
I'm just going to
cut things off at d.

526
00:29:41,750 --> 00:29:44,840
But if I know in
advance how many nodes

527
00:29:44,840 --> 00:29:48,790
are reachable
within d, I'm going

528
00:29:48,790 --> 00:29:51,970
to find all the nodes that are
reachable within d and see,

529
00:29:51,970 --> 00:29:55,230
was t one of the ones
reachable within d.

530
00:29:55,230 --> 00:29:56,470
It's the same exact idea.

531
00:29:56,470 --> 00:30:00,040
So here is the next slide,
which kind of shows that.

532
00:30:00,040 --> 00:30:02,400
So here is the definition.

533
00:30:02,400 --> 00:30:06,960
Path sub d means reachable by
a path of length of most d.

534
00:30:10,670 --> 00:30:15,020
So R sub d is all
of the ones that

535
00:30:15,020 --> 00:30:19,630
are reachable by a
path of that length.

536
00:30:19,630 --> 00:30:21,100
And c simply is the count.

537
00:30:21,100 --> 00:30:24,120
It's the number that
are reachable within d.

538
00:30:26,630 --> 00:30:28,280
So if you understood
the last slide,

539
00:30:28,280 --> 00:30:31,850
hopefully this slide will
seem kind of obvious to you.

540
00:30:31,850 --> 00:30:35,160
I'm going to just
highlight all the changes.

541
00:30:35,160 --> 00:30:39,900
So if I can now
calculate c sub d,

542
00:30:39,900 --> 00:30:44,690
which is the number reachable
by a path of most of length d,

543
00:30:44,690 --> 00:30:47,270
then I can test
whether or not nodes

544
00:30:47,270 --> 00:30:50,560
are reachable by a
path of that length.

545
00:30:50,560 --> 00:30:53,140
First, I calculate c sub d.

546
00:30:53,140 --> 00:30:57,310
I go, I pick every node as
being reachable within d or not.

547
00:30:57,310 --> 00:31:00,550
Now I just have to check that
my path that I'm guessing

548
00:31:00,550 --> 00:31:03,700
has length at most d,
instead of length of most m,

549
00:31:03,700 --> 00:31:07,080
which is what I had before.

550
00:31:07,080 --> 00:31:09,120
Keep a count of the
ones that I found.

551
00:31:09,120 --> 00:31:13,080
If that count equals c sub d,
then I know I found them all.

552
00:31:13,080 --> 00:31:16,530
If it's not equal to
c sub d, then I've

553
00:31:16,530 --> 00:31:18,090
made some bad choice
along the way,

554
00:31:18,090 --> 00:31:21,210
and I can just punt
and say I don't know.

555
00:31:21,210 --> 00:31:23,580
And if t was not one
of the ones that I've

556
00:31:23,580 --> 00:31:26,160
shown to be reachable
within d, then I

557
00:31:26,160 --> 00:31:28,350
know it's not
reachable within d.

558
00:31:28,350 --> 00:31:32,510
And so I can say no.

559
00:31:36,140 --> 00:31:39,360
So I don't know if this merits
any additional questions.

560
00:31:39,360 --> 00:31:42,292
But this is really the same.

561
00:31:42,292 --> 00:31:44,000
It's just a repeat of
the previous slide.

562
00:31:44,000 --> 00:31:48,260
What's kind of amazing
is now the last slide

563
00:31:48,260 --> 00:31:52,082
is going to be again a repeat.

564
00:31:52,082 --> 00:31:53,790
Let me just foreshadow
where we're going.

565
00:31:53,790 --> 00:31:56,540
But feel free to ask a question,
on this, or on the first slide,

566
00:31:56,540 --> 00:31:59,240
if you didn't-- on the previous
slide, if you didn't get that.

567
00:31:59,240 --> 00:32:01,310
Also, we can try to
help you out with that.

568
00:32:04,410 --> 00:32:07,090
The next slide,
what I'm going to do

569
00:32:07,090 --> 00:32:12,920
is show how to compute
all these c values.

570
00:32:12,920 --> 00:32:16,550
And I should
mention, the value c,

571
00:32:16,550 --> 00:32:18,210
which is the total
number of reachable,

572
00:32:18,210 --> 00:32:20,240
it's going to be
the same as c sub m.

573
00:32:20,240 --> 00:32:22,590
Reachable with an m, the
number of nodes of the graph.

574
00:32:22,590 --> 00:32:24,740
So if I can get up
to c sub m I'm done.

575
00:32:27,540 --> 00:32:34,620
And what I'm going to show
you is that knowing c sub i,

576
00:32:34,620 --> 00:32:36,510
I can compute c sub i plus 1.

577
00:32:36,510 --> 00:32:40,370
Or c sub d, I can
compute c sub d plus 1.

578
00:32:40,370 --> 00:32:44,000
Since I'm using d as my
index here basically.

579
00:32:44,000 --> 00:32:46,610
So c sub 0 we know is just s.

580
00:32:46,610 --> 00:32:51,120
Well, it's just 1, because
you can just start with s.

581
00:32:51,120 --> 00:32:53,300
That's the only thing
reachable within 0.

582
00:32:53,300 --> 00:32:59,600
And then, once I know that,
I can figure out c sub 1,

583
00:32:59,600 --> 00:33:03,380
c sub 2, c sub 3, and so on,
and then I get the c sub n,

584
00:33:03,380 --> 00:33:05,990
and then I have the count of
the total number reachable,

585
00:33:05,990 --> 00:33:07,970
and then I can test
the path function.

586
00:33:13,870 --> 00:33:16,210
So the trick now is
being able to count.

587
00:33:18,810 --> 00:33:21,270
Given c sub d, I would
like to figure out

588
00:33:21,270 --> 00:33:22,740
what is c sub d plus 1.

589
00:33:25,948 --> 00:33:27,240
Now, how am I going to do that?

590
00:33:27,240 --> 00:33:29,750
What I'm going to do
is that's my goal.

591
00:33:29,750 --> 00:33:32,870
What I'm going to do is
something in between.

592
00:33:32,870 --> 00:33:35,930
I'm going to do a theorem
just like this, but instead

593
00:33:35,930 --> 00:33:39,650
of giving c sub d, instead
of computing paths of d,

594
00:33:39,650 --> 00:33:42,810
I'm going to compute
paths of d plus 1.

595
00:33:42,810 --> 00:33:47,740
So knowing how many
are reachable from d,

596
00:33:47,740 --> 00:33:50,170
I'm going to give a
test for whether things

597
00:33:50,170 --> 00:33:52,870
are reachable within d plus 1.

598
00:33:52,870 --> 00:33:56,410
And the fact is, that's easy,
because this thing already

599
00:33:56,410 --> 00:34:01,020
tells me how to compute
whether I'm reachable within d.

600
00:34:01,020 --> 00:34:03,360
And being able to be
reachable from within d

601
00:34:03,360 --> 00:34:06,180
plus 1 means I have an
edge from something that's

602
00:34:06,180 --> 00:34:08,870
reachable within d.

603
00:34:08,870 --> 00:34:11,815
So if I can figure out which
are reachable within d, well,

604
00:34:11,815 --> 00:34:13,190
and I just want
to see, do I have

605
00:34:13,190 --> 00:34:18,870
an edge, do I have
an edge from one

606
00:34:18,870 --> 00:34:21,239
of the nodes that are
reachable within d.

607
00:34:21,239 --> 00:34:23,040
Then I'm reachable
within d plus 1.

608
00:34:25,610 --> 00:34:28,190
Then if I can test whether
individual nodes are

609
00:34:28,190 --> 00:34:31,880
reachable within d plus 1,
I can count how many nodes

610
00:34:31,880 --> 00:34:33,350
are reachable within d plus 1.

611
00:34:33,350 --> 00:34:36,385
That was that very first
easy theorem that I showed.

612
00:34:36,385 --> 00:34:37,760
So I know there's
a lot of pieces

613
00:34:37,760 --> 00:34:39,810
here that you have
to put together.

614
00:34:39,810 --> 00:34:42,980
But in the end, each individual
piece is not that bad.

615
00:34:46,155 --> 00:34:47,780
I don't know how many
of you follow me.

616
00:34:47,780 --> 00:34:51,360
Oh no, this is not
supposed to be here.

617
00:34:51,360 --> 00:34:53,630
There we go.

618
00:34:53,630 --> 00:34:56,199
So here is the last part,
which again, is just

619
00:34:56,199 --> 00:34:59,840
a simple modification of
what the previous slide had.

620
00:34:59,840 --> 00:35:03,050
So I'm going to
show how to compute

621
00:35:03,050 --> 00:35:05,340
the path d plus 1 function.

622
00:35:05,340 --> 00:35:08,060
So testing if there's
a path of length d

623
00:35:08,060 --> 00:35:11,610
plus 1 from s to some node t.

624
00:35:11,610 --> 00:35:14,490
But only knowing how many
nodes are reachable within d.

625
00:35:17,790 --> 00:35:19,770
So I'm going to
find all nodes that

626
00:35:19,770 --> 00:35:24,290
are reachable within d, just
like I did before, but see

627
00:35:24,290 --> 00:35:28,800
if any one of those
nodes has an edge to t.

628
00:35:28,800 --> 00:35:31,230
Not necessarily that
one is equal to t.

629
00:35:31,230 --> 00:35:33,990
Because that says that
t is reachable within d.

630
00:35:33,990 --> 00:35:37,020
But I want to know, does
it have an edge to t.

631
00:35:37,020 --> 00:35:40,250
That means t is reachable
within d plus 1.

632
00:35:40,250 --> 00:35:44,280
So if I find all the nodes that
are reachable within d, and t

633
00:35:44,280 --> 00:35:48,900
turns out to be reachable
from one of those by an edge,

634
00:35:48,900 --> 00:35:53,150
then t is reachable
within d plus 1.

635
00:35:53,150 --> 00:35:55,550
And if d is not reachable
from any of those nodes

636
00:35:55,550 --> 00:35:58,940
with an edge, then t is not
reachable from d plus 1.

637
00:35:58,940 --> 00:36:00,110
I hope you're following me.

638
00:36:00,110 --> 00:36:03,230
I'm not sure you are.

639
00:36:03,230 --> 00:36:05,600
So anyway, that's
the algorithm here.

640
00:36:05,600 --> 00:36:08,930
And the corollary
is that you can

641
00:36:08,930 --> 00:36:12,710
compute c sub d plus 1 from
c d, because if you can count

642
00:36:12,710 --> 00:36:15,030
the past, if you can
test for each node

643
00:36:15,030 --> 00:36:17,300
if it's reachable, as I
mentioned before, you go

644
00:36:17,300 --> 00:36:21,470
through all the nodes, see
whether the reachable d plus 1,

645
00:36:21,470 --> 00:36:23,780
and then count them up.

646
00:36:23,780 --> 00:36:25,220
Now I have c sub d plus 1.

647
00:36:25,220 --> 00:36:26,690
And now I'm done.

648
00:36:26,690 --> 00:36:38,000
Because I'm going to compute
each d plus 1 from the value

649
00:36:38,000 --> 00:36:39,680
d that I previously computed.

650
00:36:39,680 --> 00:36:41,510
I'm going to do
that for all these.

651
00:36:44,160 --> 00:36:46,980
Should say 0 here, actually.

652
00:36:46,980 --> 00:36:51,750
And except, if the path says--
if the path function now

653
00:36:51,750 --> 00:36:54,600
says that the answer is no.

654
00:36:54,600 --> 00:36:58,140
Because I'm trying to do
the complement of the path

655
00:36:58,140 --> 00:36:59,620
language.

656
00:36:59,620 --> 00:37:04,390
And reject if the path
thing for m says yes.

657
00:37:04,390 --> 00:37:07,750
And that's my non-deterministic
algorithm for the path

658
00:37:07,750 --> 00:37:11,720
complement problem.

659
00:37:11,720 --> 00:37:16,350
Anyway, maybe you need to
look at a little bit offline.

660
00:37:16,350 --> 00:37:19,518
It's presented in a little
bit different way in the book.

661
00:37:19,518 --> 00:37:21,810
I don't know if that will be
more or less clear to you.

662
00:37:21,810 --> 00:37:25,620
But I think this has been
a little bit more unpacked

663
00:37:25,620 --> 00:37:26,955
for the purposes of the lecture.

664
00:37:30,010 --> 00:37:31,440
So let's just see.

665
00:37:31,440 --> 00:37:35,820
I'm not getting any questions,
which probably means

666
00:37:35,820 --> 00:37:37,870
I've lost a huge chunk of you.

667
00:37:37,870 --> 00:37:40,765
But the good news is
we're going to move on

668
00:37:40,765 --> 00:37:41,640
to a different topic.

669
00:37:46,700 --> 00:37:49,880
But feel free to ask a question
on this if you want, or we're

670
00:37:49,880 --> 00:37:53,510
going to shift gears now to
talking about the hierarchy

671
00:37:53,510 --> 00:37:56,510
theorems, which is going to be
the second half of the lecture.

672
00:37:56,510 --> 00:37:59,540
Also, not so easy,
I have to say.

673
00:37:59,540 --> 00:38:01,820
Probably a little less
technical than this

674
00:38:01,820 --> 00:38:04,130
one is, but it's
also there's going

675
00:38:04,130 --> 00:38:09,140
to be spending time on just
mainly just one theorem.

676
00:38:09,140 --> 00:38:11,558
But anyway, so looking
ahead to where we're going,

677
00:38:11,558 --> 00:38:12,725
and then we'll have a break.

678
00:38:18,745 --> 00:38:22,640
What we've shown so far,
these are the major complexity

679
00:38:22,640 --> 00:38:23,210
classes.

680
00:38:23,210 --> 00:38:26,360
I'm not including, let's say,
the complementary classes,

681
00:38:26,360 --> 00:38:29,730
the co-NP type classes.

682
00:38:29,730 --> 00:38:32,360
These are the major
classes we've seen so far.

683
00:38:32,360 --> 00:38:37,730
And as we've seen, they form
a hierarchy of containments.

684
00:38:40,790 --> 00:38:42,830
Some of those
containments trivial,

685
00:38:42,830 --> 00:38:45,650
and some slightly less trivial.

686
00:38:45,650 --> 00:38:48,440
But we have not shown
whether any of these classes

687
00:38:48,440 --> 00:38:50,120
are different.

688
00:38:50,120 --> 00:38:52,970
We've pointed out that there
were some unsolved problems

689
00:38:52,970 --> 00:38:54,890
here, but do we know
any of these classes

690
00:38:54,890 --> 00:38:56,360
differ from each other?

691
00:38:56,360 --> 00:38:59,490
Or could it all
collapse down to L?

692
00:38:59,490 --> 00:39:04,080
And the answer to that is
we do know that PSPACE and L

693
00:39:04,080 --> 00:39:06,360
are actually different.

694
00:39:06,360 --> 00:39:09,430
That we can prove.

695
00:39:09,430 --> 00:39:14,830
And it relies on
the theorem that

696
00:39:14,830 --> 00:39:20,740
says if you give a Turing
machine more space,

697
00:39:20,740 --> 00:39:22,450
then you can do more things.

698
00:39:22,450 --> 00:39:28,210
So because PSPACE is a
bigger bound than log space,

699
00:39:28,210 --> 00:39:30,370
we know we can do more things.

700
00:39:30,370 --> 00:39:37,680
In fact, because NL is contained
within log squared space

701
00:39:37,680 --> 00:39:40,350
deterministically and
PSPACE is bigger than that,

702
00:39:40,350 --> 00:39:43,260
we actually can
separate PSPACE and NL.

703
00:39:43,260 --> 00:39:45,790
So we're going to
prove that today.

704
00:39:45,790 --> 00:39:47,460
So basically, the
idea of the theorem

705
00:39:47,460 --> 00:39:50,700
says that if you
give a Turing machine

706
00:39:50,700 --> 00:39:54,150
a bit more time or a bit more
space, then it can do more.

707
00:39:54,150 --> 00:39:56,100
So there are some
conditions on that

708
00:39:56,100 --> 00:39:59,460
we have to-- we'll get into.

709
00:39:59,460 --> 00:40:01,890
One of the conclusions
that we'll show

710
00:40:01,890 --> 00:40:08,213
is that time n squared,
if you compare with time--

711
00:40:08,213 --> 00:40:09,630
the things you can
do in n squared

712
00:40:09,630 --> 00:40:12,750
time versus the things you
can do in n cubed time,

713
00:40:12,750 --> 00:40:15,870
there are more things you
can do n cubed time than what

714
00:40:15,870 --> 00:40:17,160
you can do in n squared time.

715
00:40:17,160 --> 00:40:20,410
I mean, that's what
you would expect.

716
00:40:20,410 --> 00:40:22,350
But it's not the
case that everything

717
00:40:22,350 --> 00:40:26,190
we expect in complexity
theory, we can prove.

718
00:40:26,190 --> 00:40:28,260
This is one of the
things we can prove.

719
00:40:28,260 --> 00:40:31,240
So as you add more time,
you can do more things.

720
00:40:31,240 --> 00:40:32,760
So this is a proper subset here.

721
00:40:32,760 --> 00:40:34,890
So there are some
things n time n

722
00:40:34,890 --> 00:40:37,695
cubed that are not n time n
squared, and ditto for space.

723
00:40:40,400 --> 00:40:42,620
So that's going to be--

724
00:40:42,620 --> 00:40:45,830
that brings us to
our coffee break.

725
00:40:45,830 --> 00:40:48,860
And so feel free to
shoot me any questions

726
00:40:48,860 --> 00:40:53,530
about what we've done so
far, or anything else.

727
00:40:53,530 --> 00:40:58,660
And otherwise, we
will launch our timer,

728
00:40:58,660 --> 00:41:00,790
and I'll see you
in five minutes.

729
00:41:00,790 --> 00:41:03,320
OK, so getting some
good questions here.

730
00:41:03,320 --> 00:41:11,730
Could we also make a solution--
this is getting back to that,

731
00:41:11,730 --> 00:41:13,800
the logs-- the NL equals coNL.

732
00:41:13,800 --> 00:41:17,850
Somebody's saying could we just
make another selection just

733
00:41:17,850 --> 00:41:22,000
by non-deterministically
choosing C vertices,

734
00:41:22,000 --> 00:41:25,960
and then checking that
they're all reachable.

735
00:41:25,960 --> 00:41:32,320
That's effectively what
we're doing, but be careful,

736
00:41:32,320 --> 00:41:35,480
because we cannot
store C vertices.

737
00:41:35,480 --> 00:41:37,640
So that's why we're
doing them one at a time.

738
00:41:37,640 --> 00:41:40,450
We can't guess all
C vertices up front,

739
00:41:40,450 --> 00:41:43,300
because where are you
going to store all that?

740
00:41:43,300 --> 00:41:45,340
We only have log space.

741
00:41:45,340 --> 00:41:48,310
OK, another--
somebody is asking,

742
00:41:48,310 --> 00:41:50,200
how much working space
do we need for storing

743
00:41:50,200 --> 00:41:51,160
the intermediate steps?

744
00:41:51,160 --> 00:41:53,240
I'm not sure what
intermediate steps you mean.

745
00:41:53,240 --> 00:41:55,720
But if it's all to Ci values.

746
00:41:55,720 --> 00:41:59,830
You know, C going from
C0 to C1 to C2 to C3,

747
00:41:59,830 --> 00:42:01,960
we don't store those.

748
00:42:01,960 --> 00:42:07,210
All you need, you need C sub
D to calculate C sub D plus 1.

749
00:42:07,210 --> 00:42:09,190
And then you forget
C sub D. You couldn't

750
00:42:09,190 --> 00:42:10,183
store all the C values.

751
00:42:10,183 --> 00:42:11,350
But you don't need them all.

752
00:42:11,350 --> 00:42:14,020
You only need the most recent
one to go to the next one.

753
00:42:14,020 --> 00:42:15,820
OK, somebody's
asking, can I go over

754
00:42:15,820 --> 00:42:21,010
why the complement of path
in NL implies NL equal coNL?

755
00:42:21,010 --> 00:42:24,910
Because the
complement of path is,

756
00:42:24,910 --> 00:42:27,040
essentially it's coNL complete.

757
00:42:27,040 --> 00:42:29,290
I mean, it is.

758
00:42:29,290 --> 00:42:35,430
So everything in NL
is reducible to path.

759
00:42:35,430 --> 00:42:40,050
Everything in coNL is reducible
to the complement of path

760
00:42:40,050 --> 00:42:42,540
by the same reduction.

761
00:42:42,540 --> 00:42:44,910
And so if you can do
the complement of path

762
00:42:44,910 --> 00:42:49,320
in any class, you can do all of
the complements of NL languages

763
00:42:49,320 --> 00:42:50,430
in any class.

764
00:42:50,430 --> 00:42:52,740
And so you can do the
complement of path in NL,

765
00:42:52,740 --> 00:42:58,110
you can do all of the
coNL problems in NL.

766
00:42:58,110 --> 00:43:01,080
And so then NL equals coNL.

767
00:43:01,080 --> 00:43:03,570
You have to think
through the logic of it.

768
00:43:03,570 --> 00:43:05,670
That part is not hard.

769
00:43:05,670 --> 00:43:06,510
Why?

770
00:43:06,510 --> 00:43:10,410
It's enough to solve the path
complement problem in NL.

771
00:43:10,410 --> 00:43:11,520
That does everything else.

772
00:43:11,520 --> 00:43:13,395
Because it goes through
the same completeness

773
00:43:13,395 --> 00:43:16,200
phenomenon that
we've been seeing.

774
00:43:16,200 --> 00:43:19,470
Somebody is asking about
the two set problem

775
00:43:19,470 --> 00:43:21,450
that we talked about last time.

776
00:43:21,450 --> 00:43:28,020
And is it, and you know, I
pointed out that that's in NL.

777
00:43:28,020 --> 00:43:29,070
The two set problem.

778
00:43:29,070 --> 00:43:30,570
Well, the complement
of the two set,

779
00:43:30,570 --> 00:43:36,850
problem, the unsatisfiable
two set formulas.

780
00:43:36,850 --> 00:43:40,030
That's in NL language,
because you can basically

781
00:43:40,030 --> 00:43:43,115
look for a contradiction
non-deterministically in log

782
00:43:43,115 --> 00:43:43,615
space.

783
00:43:46,870 --> 00:43:49,982
I think I probably won't be able
to explain that in a minute.

784
00:43:49,982 --> 00:43:51,940
But maybe we'll have our
recitation instructors

785
00:43:51,940 --> 00:43:55,080
cover that in recitation.

786
00:43:55,080 --> 00:43:55,900
It's a nice proof.

787
00:43:55,900 --> 00:43:56,550
Not very hard.

788
00:43:56,550 --> 00:43:58,410
But it's a nice proof.

789
00:44:01,618 --> 00:44:03,910
It's something you have to
do, you have to think about,

790
00:44:03,910 --> 00:44:05,130
you have to argue.

791
00:44:05,130 --> 00:44:08,250
But it's still,
it's not super hard.

792
00:44:08,250 --> 00:44:10,110
Understanding the
two set problem.

793
00:44:10,110 --> 00:44:14,400
And the complement of two
set we showed, is in NL.

794
00:44:14,400 --> 00:44:18,270
And because NL equals coNL,
also the two set problem itself,

795
00:44:18,270 --> 00:44:21,720
without complemenation is in NL.

796
00:44:21,720 --> 00:44:23,010
And in fact, is NL complete.

797
00:44:25,845 --> 00:44:27,470
I think we're going
to have to move on.

798
00:44:30,243 --> 00:44:31,910
I'll stick around
after lecture, in case

799
00:44:31,910 --> 00:44:35,960
there's any questions that I can
answer quickly at that point.

800
00:44:35,960 --> 00:44:40,220
Sorry if I couldn't get
to your question just now.

801
00:44:40,220 --> 00:44:42,680
All right.

802
00:44:42,680 --> 00:44:44,315
Continuing on here.

803
00:44:48,280 --> 00:44:52,970
Shifting gears, the
space hierarchy theorem.

804
00:44:52,970 --> 00:45:01,110
So as I mentioned,
I think, maybe

805
00:45:01,110 --> 00:45:05,817
it's good to just go
back to this slide here.

806
00:45:05,817 --> 00:45:08,400
We're going to do the time and
space hierarchy theorems, which

807
00:45:08,400 --> 00:45:09,720
show that if you can
do a little bit more--

808
00:45:09,720 --> 00:45:12,012
if you give a little bit more
time or a little bit more

809
00:45:12,012 --> 00:45:14,460
space, you can do more things.

810
00:45:14,460 --> 00:45:18,420
We're going to do the space case
first, because that actually

811
00:45:18,420 --> 00:45:21,990
tends to be slightly, for
certain technical reasons

812
00:45:21,990 --> 00:45:24,310
slightly easier.

813
00:45:24,310 --> 00:45:28,360
So space hierarchy theorem.

814
00:45:28,360 --> 00:45:31,140
So here is the statement
of the theorem.

815
00:45:37,280 --> 00:45:45,710
So for any bound, think of s is
going to be some space bound.

816
00:45:45,710 --> 00:45:50,413
And again, f has to satisfy some
technical condition in yellow.

817
00:45:50,413 --> 00:45:52,080
Remember that it's
yellow because that's

818
00:45:52,080 --> 00:45:53,205
going to be relevant later.

819
00:45:55,840 --> 00:45:59,640
So there's going to be
some technical condition.

820
00:45:59,640 --> 00:46:03,840
No matter what function you
have, whatever space bound

821
00:46:03,840 --> 00:46:05,340
you have, as long
as it satisfies

822
00:46:05,340 --> 00:46:08,860
this condition, which is a mild
condition, but you need it.

823
00:46:08,860 --> 00:46:11,460
Whatever space
bound you have, you

824
00:46:11,460 --> 00:46:15,730
can find a language
A which requires

825
00:46:15,730 --> 00:46:19,300
exactly that much space.

826
00:46:19,300 --> 00:46:21,780
So if f is like n
cubed, we're going

827
00:46:21,780 --> 00:46:24,468
to find a language A that
requires n cubed space.

828
00:46:24,468 --> 00:46:26,760
If it's n to the hundredth,
we can find a language that

829
00:46:26,760 --> 00:46:28,980
requires n to the
hundredth space,

830
00:46:28,980 --> 00:46:32,280
and cannot be done
with n to 99-th space.

831
00:46:32,280 --> 00:46:36,570
Whatever it is, you can find
a language that requires

832
00:46:36,570 --> 00:46:38,220
exactly that much space.

833
00:46:38,220 --> 00:46:40,300
And if you like it a
little bit more formally,

834
00:46:40,300 --> 00:46:43,830
so that means that it can be
decided in that much space,

835
00:46:43,830 --> 00:46:45,840
but it cannot be
decided in less space.

836
00:46:49,987 --> 00:46:51,570
Framing it at a
slightly different way

837
00:46:51,570 --> 00:46:54,210
in terms of our
space classes, I'm

838
00:46:54,210 --> 00:46:57,270
going to define a
notion which is kind--

839
00:46:57,270 --> 00:47:00,690
it's not said this
way in the book,

840
00:47:00,690 --> 00:47:03,600
but maybe it's a helpful
way to write it down.

841
00:47:03,600 --> 00:47:06,480
It's space little o of f of n.

842
00:47:06,480 --> 00:47:07,980
So those are all
the things that you

843
00:47:07,980 --> 00:47:13,000
can do by a function that's a
little o of f of n in space.

844
00:47:13,000 --> 00:47:16,990
So space little o of f of n is
properly contained within space

845
00:47:16,990 --> 00:47:19,147
f of n.

846
00:47:19,147 --> 00:47:20,730
In other words,
there's something here

847
00:47:20,730 --> 00:47:21,647
which is not in there.

848
00:47:24,280 --> 00:47:26,380
Picture it
pictorially, I'm going

849
00:47:26,380 --> 00:47:29,860
to exhibit some language,
some explicit language

850
00:47:29,860 --> 00:47:34,947
A, which I can do in this much
space, but not in any less.

851
00:47:34,947 --> 00:47:37,030
Now, you can sort of think
of this as a little bit

852
00:47:37,030 --> 00:47:39,790
like the situation for
context-free language

853
00:47:39,790 --> 00:47:43,420
and regular languages, where we
exhibited a particular language

854
00:47:43,420 --> 00:47:45,820
that differentiated-- that
was in context free but not

855
00:47:45,820 --> 00:47:46,840
regular.

856
00:47:46,840 --> 00:47:50,130
And we're going to kind
of do the same thing now.

857
00:47:50,130 --> 00:47:53,640
But the one key difference is
that in the case of separating

858
00:47:53,640 --> 00:47:55,230
the context free
and the regular,

859
00:47:55,230 --> 00:47:59,740
we could give a nice language,
like 0 to the k, 1 to the k.

860
00:47:59,740 --> 00:48:03,090
Here, the language is not going
to be so nice to describe.

861
00:48:03,090 --> 00:48:06,030
It's going to be the language
that some Turing machine we're

862
00:48:06,030 --> 00:48:07,687
going to give decides.

863
00:48:07,687 --> 00:48:09,270
But you're not going
to be able to get

864
00:48:09,270 --> 00:48:12,300
a nice simple understanding of
A. It's going to be whatever

865
00:48:12,300 --> 00:48:13,700
that Turing machine does.

866
00:48:13,700 --> 00:48:17,070
And in that sense, it's
not a very natural language

867
00:48:17,070 --> 00:48:20,850
that's easy to sort of
get your mind around.

868
00:48:20,850 --> 00:48:26,970
So the outline, and really, you
don't have to worry about this,

869
00:48:26,970 --> 00:48:28,650
but maybe it helps.

870
00:48:28,650 --> 00:48:33,870
It's really going to be a kind
of a diagonalization proof.

871
00:48:33,870 --> 00:48:37,180
The way this machine
D is going to operate.

872
00:48:37,180 --> 00:48:42,150
So D is going to give
you my language A.

873
00:48:42,150 --> 00:48:44,280
So D is going to be
designed, and I'm

874
00:48:44,280 --> 00:48:46,920
going to show you D
on the next slide.

875
00:48:46,920 --> 00:48:51,600
D is going to run within my
target space bound, f of n.

876
00:48:51,600 --> 00:48:52,680
And here's the key.

877
00:48:52,680 --> 00:48:54,242
Here's the kicker.

878
00:48:54,242 --> 00:48:58,460
D is going to be designed to
make sure that its language

879
00:48:58,460 --> 00:49:02,640
cannot be done in less space.

880
00:49:02,640 --> 00:49:05,220
And the way it does
that is it makes sure

881
00:49:05,220 --> 00:49:09,810
that its language is different
from any language that

882
00:49:09,810 --> 00:49:16,312
is decidable by a Turing
machine in less space.

883
00:49:16,312 --> 00:49:18,520
And it's going to be different
in at least one place.

884
00:49:22,020 --> 00:49:26,180
So any-- D is going to guarantee
that its language cannot be

885
00:49:26,180 --> 00:49:28,850
done in little o
of f of n space,

886
00:49:28,850 --> 00:49:31,490
because it's going to be
different from every language

887
00:49:31,490 --> 00:49:37,220
that's doable in little o
of f of n space somewhere.

888
00:49:37,220 --> 00:49:38,090
That's the point.

889
00:49:38,090 --> 00:49:41,330
And then the language A is
going to be the language

890
00:49:41,330 --> 00:49:47,410
of this Turing machine D.

891
00:49:47,410 --> 00:49:49,130
So it looks like a tall order.

892
00:49:49,130 --> 00:49:51,940
The D has to make
sure that each--

893
00:49:51,940 --> 00:49:55,390
that for every
machine, its language

894
00:49:55,390 --> 00:49:58,420
differs from that
machine's language,

895
00:49:58,420 --> 00:50:01,360
if that machine is running in
little low o of f of n space.

896
00:50:01,360 --> 00:50:04,150
But it's basically going
to be a diagonalization.

897
00:50:04,150 --> 00:50:07,960
So for all of the different
possible inputs to D,

898
00:50:07,960 --> 00:50:10,570
that input is going
to actually code up

899
00:50:10,570 --> 00:50:15,207
a machine, on which
we're going to make sure

900
00:50:15,207 --> 00:50:16,790
that we're different
from that machine

901
00:50:16,790 --> 00:50:19,970
if it's a small space machine.

902
00:50:19,970 --> 00:50:21,050
Let's see if that--

903
00:50:21,050 --> 00:50:23,670
So I can take a couple
of questions here.

904
00:50:23,670 --> 00:50:25,070
Does f have to be computable?

905
00:50:25,070 --> 00:50:27,597
So that's going to be
one of the conditions

906
00:50:27,597 --> 00:50:29,180
that we're going to
have to guarantee.

907
00:50:29,180 --> 00:50:31,130
Where f satisfies a
technical condition,

908
00:50:31,130 --> 00:50:32,990
yeah, it's going to end
up being have-- it's

909
00:50:32,990 --> 00:50:33,740
going to be computable.

910
00:50:33,740 --> 00:50:34,670
But that's not enough.

911
00:50:38,653 --> 00:50:39,820
Good, good question, though.

912
00:50:43,960 --> 00:50:49,510
OK, so let's move on from there.

913
00:50:49,510 --> 00:50:53,760
So here is-- now what my job is
to give you this Turing machine

914
00:50:53,760 --> 00:50:58,500
D. So D, D's language is
going to be my language A,

915
00:50:58,500 --> 00:51:04,790
which requires f of n space,
cannot be done in less.

916
00:51:04,790 --> 00:51:06,230
OK, oops.

917
00:51:06,230 --> 00:51:07,520
I need to--

918
00:51:07,520 --> 00:51:10,010
I need the full slide here,
so I have to take myself out.

919
00:51:16,070 --> 00:51:17,270
All right.

920
00:51:17,270 --> 00:51:19,650
Now, this is my goal.

921
00:51:19,650 --> 00:51:22,070
I want to exhibit
this language A, which

922
00:51:22,070 --> 00:51:24,890
I can do in this much
space, but not in any less.

923
00:51:29,340 --> 00:51:33,750
And so I'm going to give this
machine D, as I mentioned,

924
00:51:33,750 --> 00:51:35,910
where A is D's language.

925
00:51:35,910 --> 00:51:37,800
D runs in order f of n space.

926
00:51:37,800 --> 00:51:40,630
And that sort of-- that
achieves this part.

927
00:51:40,630 --> 00:51:47,050
And D, make sure that its
language cannot be done in any

928
00:51:47,050 --> 00:51:48,860
less space.

929
00:51:48,860 --> 00:51:50,800
So that achieves this part.

930
00:51:50,800 --> 00:51:52,420
So it's different
from the language

931
00:51:52,420 --> 00:51:55,525
of any machine that runs in
little o of f of n space.

932
00:52:01,600 --> 00:52:08,520
So this is how D
is going to work.

933
00:52:08,520 --> 00:52:10,650
I'm going to try to give
you a little picture

934
00:52:10,650 --> 00:52:14,880
to help see to accompany
the description.

935
00:52:14,880 --> 00:52:20,500
So D gets its input w,
which is of length n.

936
00:52:20,500 --> 00:52:27,610
The very first thing D does
is it marks off f of n space.

937
00:52:27,610 --> 00:52:29,560
Because it's only
allowed to use--

938
00:52:29,560 --> 00:52:33,130
we're only going to allow
D to use f of n space.

939
00:52:33,130 --> 00:52:37,180
Because otherwise, we're
in danger of D not--

940
00:52:37,180 --> 00:52:40,000
of A not being in space f of n.

941
00:52:40,000 --> 00:52:43,300
So D is going to guarantee
that, by making sure

942
00:52:43,300 --> 00:52:46,810
it's going to mark
off f of n space.

943
00:52:46,810 --> 00:52:49,570
And if it ever tries to use
more than that, it just rejects.

944
00:52:52,090 --> 00:52:56,250
But by virtue of that,
we're sure that D's language

945
00:52:56,250 --> 00:52:57,450
is in space f of n.

946
00:52:57,450 --> 00:53:00,090
Because D is an f of n
space Turing machine.

947
00:53:00,090 --> 00:53:03,130
And it's going to be decided.

948
00:53:03,130 --> 00:53:09,510
So this part so far
is not too hard.

949
00:53:09,510 --> 00:53:12,010
Now we're going to start
getting into the meat here.

950
00:53:12,010 --> 00:53:22,330
So if w-- now, what we want
to think of w as a description

951
00:53:22,330 --> 00:53:24,670
of a machine that
we're going to feed--

952
00:53:24,670 --> 00:53:26,920
that's going to run on w.

953
00:53:26,920 --> 00:53:29,090
So this is going
to a little bit,

954
00:53:29,090 --> 00:53:32,710
you know, back to
an earlier when we

955
00:53:32,710 --> 00:53:34,000
talked about diagonalization.

956
00:53:34,000 --> 00:53:36,010
So don't get thrown off by this.

957
00:53:38,800 --> 00:53:42,040
We're going to think of w
not only as the input to D,

958
00:53:42,040 --> 00:53:46,450
but it's also going to be
the description of a machine.

959
00:53:46,450 --> 00:53:49,070
And if it turns out that w
doesn't describe anything,

960
00:53:49,070 --> 00:53:52,330
it's just a junk w, then
we're not interested.

961
00:53:52,330 --> 00:53:55,060
We're just going to
reject on that w.

962
00:53:55,060 --> 00:53:57,100
We're only interested
in the w's that

963
00:53:57,100 --> 00:54:03,410
do describe some machine M.

964
00:54:03,410 --> 00:54:08,330
So if M-- if w describes
some machine M,

965
00:54:08,330 --> 00:54:13,010
then we're going to run M on w.

966
00:54:13,010 --> 00:54:17,750
And we're going to do the
opposite of what M does.

967
00:54:17,750 --> 00:54:19,510
That's the whole idea.

968
00:54:19,510 --> 00:54:23,350
We're just going to make
sure that what we're doing

969
00:54:23,350 --> 00:54:24,970
is not the same as
what M is doing.

970
00:54:28,360 --> 00:54:36,410
So at a high level, the basic
idea for this is not hard.

971
00:54:36,410 --> 00:54:40,380
So we're going to
simulate M on w.

972
00:54:40,380 --> 00:54:43,427
If M rejects, then we'll accept.

973
00:54:43,427 --> 00:54:44,760
If M accepts, then we'll reject.

974
00:54:44,760 --> 00:54:46,372
We're just going
to do the opposite.

975
00:54:53,460 --> 00:54:55,460
And I think that is--

976
00:54:55,460 --> 00:54:57,650
so we have to be careful
when we do the simulation.

977
00:54:57,650 --> 00:54:59,040
This is a little
bit of a detail,

978
00:54:59,040 --> 00:55:02,443
but this is a proof where
you need to pay attention

979
00:55:02,443 --> 00:55:03,110
to some details.

980
00:55:05,810 --> 00:55:13,220
The cost of simulating M on
D is only a constant factor.

981
00:55:13,220 --> 00:55:17,090
Because if M uses a
certain amount of space,

982
00:55:17,090 --> 00:55:20,480
when D is simulating
M, you know,

983
00:55:20,480 --> 00:55:23,540
M may have a larger taper
alphabet than D does,

984
00:55:23,540 --> 00:55:29,120
but D can then encode M's
tape by using several cells

985
00:55:29,120 --> 00:55:30,710
for each of M's cells.

986
00:55:30,710 --> 00:55:32,760
But it's only going to
be a constant factor.

987
00:55:32,760 --> 00:55:36,170
And that's important
here, because we

988
00:55:36,170 --> 00:55:41,700
have to make sure that
if this was a big blowup,

989
00:55:41,700 --> 00:55:47,370
D would not be able to run M.
I think I'm sort of arguing

990
00:55:47,370 --> 00:55:49,290
the details without
making sure we understand

991
00:55:49,290 --> 00:55:51,210
the fundamental concept.

992
00:55:51,210 --> 00:55:54,090
So let me back up.

993
00:55:57,000 --> 00:56:02,070
The point is that D is doing
something the opposite of M.

994
00:56:02,070 --> 00:56:05,640
Now, D can't be
different from every M,

995
00:56:05,640 --> 00:56:08,250
because D itself is a
Turing machine, of course.

996
00:56:08,250 --> 00:56:11,460
But the thing is that
D is only running

997
00:56:11,460 --> 00:56:13,510
with an f of n tape cells.

998
00:56:13,510 --> 00:56:15,960
So it has to be able to
do that simulation of M

999
00:56:15,960 --> 00:56:17,370
within that amount of tape.

1000
00:56:17,370 --> 00:56:19,380
If M is using a
lot of tape, then D

1001
00:56:19,380 --> 00:56:21,922
is going to use a lot of tape,
and it's just going to reject.

1002
00:56:24,130 --> 00:56:28,080
So this is only going to
really come into play,

1003
00:56:28,080 --> 00:56:30,240
being able to
simulate M, if M is

1004
00:56:30,240 --> 00:56:33,750
using a small amount
of space, so that D

1005
00:56:33,750 --> 00:56:35,910
can do this simulation.

1006
00:56:35,910 --> 00:56:38,213
Let's just see, maybe--

1007
00:56:38,213 --> 00:56:39,880
so there's going to
be some issues here.

1008
00:56:39,880 --> 00:56:41,380
But before I get
to that, let's just

1009
00:56:41,380 --> 00:56:43,410
see what your questions are.

1010
00:56:43,410 --> 00:56:46,710
How can a Turing machine know if
w is encoding some other Turing

1011
00:56:46,710 --> 00:56:48,240
machine?

1012
00:56:48,240 --> 00:56:49,590
Oh, that's simple.

1013
00:56:49,590 --> 00:56:52,290
You know, what is a coding
of a Turing machine?

1014
00:56:52,290 --> 00:56:56,090
It's just the standard--
we have a standard coding.

1015
00:56:56,090 --> 00:56:59,100
It's just coding the
rules of the machine.

1016
00:56:59,100 --> 00:57:01,680
So it has to have states,
transition function,

1017
00:57:01,680 --> 00:57:02,770
blah, blah, blah.

1018
00:57:02,770 --> 00:57:04,530
So it just has to
be some-- whatever

1019
00:57:04,530 --> 00:57:06,450
our encoding for
the Turing machine

1020
00:57:06,450 --> 00:57:11,927
is, we can always test whether a
string is a legitimate encoding

1021
00:57:11,927 --> 00:57:12,760
of a Turing machine.

1022
00:57:12,760 --> 00:57:15,870
So that shouldn't be bad.

1023
00:57:15,870 --> 00:57:18,270
Somebody says, why do we
reject if we use more than f

1024
00:57:18,270 --> 00:57:19,620
of n cells?

1025
00:57:19,620 --> 00:57:22,640
Isn't it OK to use order f of n?

1026
00:57:22,640 --> 00:57:23,550
Yes, it could be.

1027
00:57:23,550 --> 00:57:25,870
But we have to cut
it off somewhere.

1028
00:57:25,870 --> 00:57:28,700
It might be-- it's OK,
we could use 2 f of n.

1029
00:57:28,700 --> 00:57:30,110
We could use 10 f of n.

1030
00:57:30,110 --> 00:57:33,680
But we have to have
some constant for D.

1031
00:57:33,680 --> 00:57:35,720
And that's just
simply constant 1.

1032
00:57:35,720 --> 00:57:39,470
So D has to run
within f of n cells.

1033
00:57:39,470 --> 00:57:41,960
And that's going to
be good enough for us.

1034
00:57:41,960 --> 00:57:45,320
OK, do we have to make sure that
M runs in little o of f of n?

1035
00:57:45,320 --> 00:57:47,810
So we can't really
tell whether M is

1036
00:57:47,810 --> 00:57:50,220
running in little o of f of n.

1037
00:57:50,220 --> 00:57:53,580
All we can tell is whether
we can finish the simulation.

1038
00:57:53,580 --> 00:57:55,200
So that's actually going to be--

1039
00:57:55,200 --> 00:57:58,020
maybe you can just hold off on
that question, because there

1040
00:57:58,020 --> 00:58:01,140
is a point that we have to
follow up on in that, which

1041
00:58:01,140 --> 00:58:06,420
is just because
we may or may not

1042
00:58:06,420 --> 00:58:10,200
be able to finish
simulating M on this w

1043
00:58:10,200 --> 00:58:12,990
doesn't necessarily tell us what
the asymptotic behavior of M

1044
00:58:12,990 --> 00:58:13,490
is.

1045
00:58:13,490 --> 00:58:15,480
But we'll have to
look at that in a bit.

1046
00:58:15,480 --> 00:58:17,790
So somebody saying, what
happens if M loops on w?

1047
00:58:17,790 --> 00:58:20,207
That's going to be one of our
issues we have to deal with.

1048
00:58:20,207 --> 00:58:21,950
That's a good question there.

1049
00:58:21,950 --> 00:58:25,030
Step two alone can use
more than f of n cells.

1050
00:58:25,030 --> 00:58:27,620
Yes, step two alone can
use more than f of n cells.

1051
00:58:27,620 --> 00:58:30,428
If it does, we're just
going to end up rejecting.

1052
00:58:30,428 --> 00:58:31,970
So we're getting
good questions here.

1053
00:58:31,970 --> 00:58:33,920
Some of them I'm going
to address anyway,

1054
00:58:33,920 --> 00:58:35,330
so why don't we just move on.

1055
00:58:40,810 --> 00:58:42,250
So here is sort of a question.

1056
00:58:42,250 --> 00:58:46,135
I think this is one of the
questions that related to one

1057
00:58:46,135 --> 00:58:47,260
of the ones that got asked.

1058
00:58:47,260 --> 00:58:50,510
What happens if it runs in
little o of f of n space?

1059
00:58:50,510 --> 00:58:53,110
So remember, what
we're trying to do

1060
00:58:53,110 --> 00:58:55,870
is be different from
every small space.

1061
00:58:55,870 --> 00:58:58,790
You know, little o of
f of n space machine.

1062
00:58:58,790 --> 00:59:01,960
So what if M runs in
little o of f of n space,

1063
00:59:01,960 --> 00:59:04,320
but has a big constant?

1064
00:59:04,320 --> 00:59:05,960
So what I mean by
that concretely,

1065
00:59:05,960 --> 00:59:09,320
is suppose D is
an n cubed space.

1066
00:59:09,320 --> 00:59:13,970
So suppose we're trying
to get A in n cubed space,

1067
00:59:13,970 --> 00:59:18,030
but show it's not
in n squared space.

1068
00:59:18,030 --> 00:59:20,950
So D is going to run in n cubed.

1069
00:59:20,950 --> 00:59:25,020
And we have to make sure that
any machine that's running in n

1070
00:59:25,020 --> 00:59:28,302
squared space cannot
do the same language.

1071
00:59:28,302 --> 00:59:30,010
So we're going to be
different from that.

1072
00:59:30,010 --> 00:59:37,190
But the problem is
that the machine

1073
00:59:37,190 --> 00:59:42,280
M might be running
in n squared space,

1074
00:59:42,280 --> 00:59:43,550
but with a huge constant.

1075
00:59:43,550 --> 00:59:46,130
So it might be running
in a million n squared.

1076
00:59:46,130 --> 00:59:51,370
So that's still a machine that's
running in little o of n cubed.

1077
00:59:51,370 --> 00:59:52,870
And we have to be
different from it.

1078
00:59:52,870 --> 00:59:55,510
But for the particular
w we're working on,

1079
00:59:55,510 --> 00:59:58,240
we might not have
enough space to run M,

1080
00:59:58,240 --> 01:00:01,180
because of the huge constant.

1081
01:00:01,180 --> 01:00:02,890
The asymptotic
behavior is only going

1082
01:00:02,890 --> 01:00:06,670
to be relevant for large W. For
small w, we may not see that.

1083
01:00:06,670 --> 01:00:11,050
We may not have enough
space to run M. So what

1084
01:00:11,050 --> 01:00:12,640
are we going to do to fix that?

1085
01:00:12,640 --> 01:00:16,250
We're going to run that M on
infinitely many different w's.

1086
01:00:16,250 --> 01:00:19,600
There's going to be infinitely
many different w's that are all

1087
01:00:19,600 --> 01:00:22,380
going to encode the same M.

1088
01:00:22,380 --> 01:00:24,240
And the way I'm
going to do that is

1089
01:00:24,240 --> 01:00:30,780
by thinking of w
as representing M,

1090
01:00:30,780 --> 01:00:37,120
but having an unbounded number
of trailing zeros after that.

1091
01:00:37,120 --> 01:00:39,690
So I'm going to strip off--
the very first thing I'm

1092
01:00:39,690 --> 01:00:41,790
going to do with w, is
I'm going to strip off

1093
01:00:41,790 --> 01:00:44,310
the trailing zeros up
until the final one.

1094
01:00:44,310 --> 01:00:45,630
I'm going to remove those.

1095
01:00:45,630 --> 01:00:50,290
And then take the rest, as the
description of the machine.

1096
01:00:50,290 --> 01:00:52,860
So now, I'm going
to have potentially

1097
01:00:52,860 --> 01:00:57,720
w's that have an enormous
number of zeros at the end,

1098
01:00:57,720 --> 01:01:01,320
big enough so that I can see
the asymptotic behavior of M,

1099
01:01:01,320 --> 01:01:05,250
and that if M is really running
in little o of f of n space,

1100
01:01:05,250 --> 01:01:08,998
I'll have enough space to
run M to completion on w.

1101
01:01:08,998 --> 01:01:11,040
And so then I'll be able
to be different from it.

1102
01:01:13,820 --> 01:01:16,110
So I'm going to
showing that over here.

1103
01:01:16,110 --> 01:01:20,170
So here's a very large
W. I'm going to strip off

1104
01:01:20,170 --> 01:01:22,300
the trailing zeros.

1105
01:01:22,300 --> 01:01:23,890
The rest of it is
just going to be M.

1106
01:01:23,890 --> 01:01:28,080
And I'm going to run
this M on the whole w.

1107
01:01:28,080 --> 01:01:30,390
The entire w, without
the zeroes stripped off.

1108
01:01:30,390 --> 01:01:36,060
So now M is going to be
running on a very large input,

1109
01:01:36,060 --> 01:01:41,700
big enough so that D, which
has asymptotically more space

1110
01:01:41,700 --> 01:01:46,530
than M does, will have enough
space to run M to completion.

1111
01:01:46,530 --> 01:01:48,150
Now, another question
that got asked.

1112
01:01:48,150 --> 01:01:49,950
What happens if M loops?

1113
01:01:49,950 --> 01:01:53,020
That's going to be a problem,
because D always has to hold.

1114
01:01:53,020 --> 01:01:55,740
And if it just
blindly simulates M,

1115
01:01:55,740 --> 01:01:58,560
then D might be
looping on M. Not

1116
01:01:58,560 --> 01:02:00,900
if M is going to use a
lot of space, by the way.

1117
01:02:00,900 --> 01:02:04,260
Because then D is going
to catch it in step one.

1118
01:02:04,260 --> 01:02:09,930
But if M loops on a small
amount of space, then

1119
01:02:09,930 --> 01:02:15,600
D might end up looping,
as presently constructed.

1120
01:02:15,600 --> 01:02:17,480
So what I'm going
to do is I'm going

1121
01:02:17,480 --> 01:02:20,450
to put a counter which
makes it stop if it

1122
01:02:20,450 --> 01:02:24,090
runs for 2 to f of n space.

1123
01:02:24,090 --> 01:02:26,280
So basically, because
that's how long

1124
01:02:26,280 --> 01:02:30,590
D could possibly run
without looping anyway,

1125
01:02:30,590 --> 01:02:32,940
and M could be running
without looping anyway.

1126
01:02:32,940 --> 01:02:37,160
And so we're going to run
it for this number of steps.

1127
01:02:37,160 --> 01:02:41,270
And I'm going to reject
if it hasn't yet halted,

1128
01:02:41,270 --> 01:02:42,800
as well as that.

1129
01:02:42,800 --> 01:02:46,440
Because it has to be looping
at that point anyway.

1130
01:02:46,440 --> 01:02:48,253
And so it's not
interesting for us.

1131
01:02:48,253 --> 01:02:49,670
It doesn't matter
what we're going

1132
01:02:49,670 --> 01:02:51,080
to do if it hasn't halted.

1133
01:02:51,080 --> 01:02:55,230
Because M is not a decider.

1134
01:02:55,230 --> 01:02:59,290
And the last thing
is how to compute f.

1135
01:02:59,290 --> 01:03:01,300
So I'll try to address
some questions here

1136
01:03:01,300 --> 01:03:03,910
in our remaining time.

1137
01:03:03,910 --> 01:03:05,840
How to compute f.

1138
01:03:05,840 --> 01:03:09,410
So to mark off f of n cells,
we also have to compute f.

1139
01:03:09,410 --> 01:03:11,720
I didn't think any of you
guys asked that question,

1140
01:03:11,720 --> 01:03:13,880
except maybe sort at
the very beginning,

1141
01:03:13,880 --> 01:03:17,020
about f being a
computable function.

1142
01:03:17,020 --> 01:03:19,120
Certainly, f is going to
have to be computable.

1143
01:03:19,120 --> 01:03:21,040
But not only does it
have to be computable,

1144
01:03:21,040 --> 01:03:24,005
it has to be computable
within the space bound.

1145
01:03:24,005 --> 01:03:25,630
And that's just going
to be a condition

1146
01:03:25,630 --> 01:03:27,100
we're going to impose on f.

1147
01:03:27,100 --> 01:03:29,710
It's so called space
constructable, namely,

1148
01:03:29,710 --> 01:03:34,060
that you can compute it
within its own space bound.

1149
01:03:34,060 --> 01:03:36,940
And all nice functions
that we care about

1150
01:03:36,940 --> 01:03:39,430
are going to be
space constructable.

1151
01:03:39,430 --> 01:03:46,300
So it doesn't turn out to
be an obstacle to applying

1152
01:03:46,300 --> 01:03:49,420
the hierarchy theorem, but it
is a condition that we need.

1153
01:03:49,420 --> 01:03:54,310
It actually is not true
without that condition.

1154
01:03:54,310 --> 01:03:56,740
Let's just-- oh, I
have a check-in here.

1155
01:03:56,740 --> 01:03:58,795
Maybe if we can take a
couple of questions first.

1156
01:04:03,180 --> 01:04:06,570
Some of you are anticipating
my check-in actually,

1157
01:04:06,570 --> 01:04:09,150
which is good.

1158
01:04:09,150 --> 01:04:11,550
So let me hold off on those.

1159
01:04:11,550 --> 01:04:16,360
Sorry, a bit confused about what
is M. Can we say D is input M,

1160
01:04:16,360 --> 01:04:17,710
and simulates M on-- yeah.

1161
01:04:17,710 --> 01:04:23,800
So somebody is saying, can
we say that D has input M,

1162
01:04:23,800 --> 01:04:25,570
and simulates M on itself?

1163
01:04:25,570 --> 01:04:28,070
Yes, that's exactly
what's happening.

1164
01:04:28,070 --> 01:04:31,750
The reason why we're doing that
is because we have to cover all

1165
01:04:31,750 --> 01:04:33,460
possible M's.

1166
01:04:33,460 --> 01:04:37,120
So as we get all
possible inputs w,

1167
01:04:37,120 --> 01:04:39,460
they're going to range
over all possible M's.

1168
01:04:39,460 --> 01:04:43,030
And so every possible M
is going to get addressed

1169
01:04:43,030 --> 01:04:47,230
to see if we can run it
within the space bound,

1170
01:04:47,230 --> 01:04:49,930
and be different from it.

1171
01:04:49,930 --> 01:04:53,020
D's job is to be different
from each of those M's.

1172
01:04:53,020 --> 01:04:55,600
But it's not-- again,
there is some details here

1173
01:04:55,600 --> 01:04:59,470
that got raised in these issues.

1174
01:04:59,470 --> 01:05:04,430
But in a sense, this is
just kind of more technical,

1175
01:05:04,430 --> 01:05:07,000
I would focus on understanding
what I originally wrote down,

1176
01:05:07,000 --> 01:05:08,350
because that's the main idea.

1177
01:05:08,350 --> 01:05:13,060
The rest of it is just
implementation details.

1178
01:05:13,060 --> 01:05:14,330
So why don't I--

1179
01:05:14,330 --> 01:05:16,690
can I give an example of
a nonspace constructable

1180
01:05:16,690 --> 01:05:17,710
function?

1181
01:05:17,710 --> 01:05:19,380
Yes.

1182
01:05:19,380 --> 01:05:22,330
Log log log n space.

1183
01:05:22,330 --> 01:05:26,280
You cannot compute log log log
n space within log log log n

1184
01:05:26,280 --> 01:05:27,180
space.

1185
01:05:27,180 --> 01:05:29,940
And in fact, it's
known that there's

1186
01:05:29,940 --> 01:05:34,230
nothing new between constant
space, which is just regular,

1187
01:05:34,230 --> 01:05:36,180
and log log log n space.

1188
01:05:36,180 --> 01:05:38,130
Anything you can
do in log log log

1189
01:05:38,130 --> 01:05:40,570
n space is a regular language.

1190
01:05:40,570 --> 01:05:45,060
So the hierarchy theorem
doesn't want to apply there.

1191
01:05:45,060 --> 01:05:50,190
Because well, it applies,
but that's not a--

1192
01:05:50,190 --> 01:05:52,670
it's not space constructable.

1193
01:05:52,670 --> 01:05:59,360
To find higher level large
nonspace constructable

1194
01:05:59,360 --> 01:06:06,840
functions, you can do it, but
they're not easy to describe.

1195
01:06:06,840 --> 01:06:08,580
Let's do our check-in here.

1196
01:06:08,580 --> 01:06:10,473
What happens when
we run D on itself?

1197
01:06:10,473 --> 01:06:12,390
I got a couple of people
asking me about that.

1198
01:06:12,390 --> 01:06:15,030
So this is just a good
lead in to our check-in.

1199
01:06:15,030 --> 01:06:16,050
And this a little--

1200
01:06:16,050 --> 01:06:17,550
you really have to
understand what's

1201
01:06:17,550 --> 01:06:23,740
going on, to see what does D
do when if you feed in itself,

1202
01:06:23,740 --> 01:06:25,630
maybe with some trailing zeros.

1203
01:06:25,630 --> 01:06:28,690
Because remember, the algorithm
strips off trailing zeros.

1204
01:06:28,690 --> 01:06:31,400
So what does it do in that case?

1205
01:06:31,400 --> 01:06:33,850
So here are my options there.

1206
01:06:33,850 --> 01:06:39,232
You can get to pick which
one you think is the answer.

1207
01:06:39,232 --> 01:06:40,690
So I'll give you
another 30 seconds

1208
01:06:40,690 --> 01:06:43,510
on this, because this requires
a little bit of thinking.

1209
01:06:43,510 --> 01:06:45,190
If you want to invest in it.

1210
01:06:45,190 --> 01:06:45,760
All right.

1211
01:06:50,500 --> 01:06:52,000
Wrap this up, guys.

1212
01:06:55,160 --> 01:06:56,210
5 seconds to go.

1213
01:07:01,000 --> 01:07:08,070
OK, I'm going to end it, so get
your participation points in.

1214
01:07:08,070 --> 01:07:10,120
A bunch of you have
not said anything.

1215
01:07:10,120 --> 01:07:11,920
Come on.

1216
01:07:11,920 --> 01:07:15,480
I can see the count here,
and it's three or four

1217
01:07:15,480 --> 01:07:17,460
of you are not answered.

1218
01:07:17,460 --> 01:07:18,960
Well, you're going to lose out.

1219
01:07:18,960 --> 01:07:20,050
Closing.

1220
01:07:20,050 --> 01:07:20,550
All right.

1221
01:07:20,550 --> 01:07:24,180
So the right answer is, in
fact, C. It does reject.

1222
01:07:24,180 --> 01:07:25,680
Let's just understand
what happened.

1223
01:07:25,680 --> 01:07:27,873
It's definitely we don't
get a contradiction.

1224
01:07:27,873 --> 01:07:29,790
I mean, this is an
algorithm I just described.

1225
01:07:29,790 --> 01:07:30,930
It's going to do something.

1226
01:07:34,770 --> 01:07:39,180
I'm assuming the people who
picked E are having fun,

1227
01:07:39,180 --> 01:07:41,160
as I did when I came
up with the check-in.

1228
01:07:45,258 --> 01:07:48,388
But not a question--
answer A is not

1229
01:07:48,388 --> 01:07:50,680
going to be good either,
because D has to be a decider.

1230
01:07:50,680 --> 01:07:52,247
So it can't loop on anything.

1231
01:07:52,247 --> 01:07:53,830
So the only sort of
reasonable answers

1232
01:07:53,830 --> 01:07:56,770
are reject, accept, or reject.

1233
01:07:56,770 --> 01:08:03,390
When you run D on itself,
what's it going to try to do?

1234
01:08:03,390 --> 01:08:04,950
It's going to-- the
very first thing

1235
01:08:04,950 --> 01:08:08,460
it's going to mark
off f of n tape cells.

1236
01:08:08,460 --> 01:08:11,580
And then it's going to get
its input, which is itself,

1237
01:08:11,580 --> 01:08:14,520
tries to simulate itself
on the same input.

1238
01:08:14,520 --> 01:08:17,580
That simulated D is
also going to try

1239
01:08:17,580 --> 01:08:19,620
to mark off f of n tape cells.

1240
01:08:19,620 --> 01:08:22,979
But due to some
simulation-- there's

1241
01:08:22,979 --> 01:08:25,410
going to be some cost
to doing the simulation.

1242
01:08:25,410 --> 01:08:27,270
When the simulated
D is going to try

1243
01:08:27,270 --> 01:08:29,460
to mark off f of
n tape cells it's

1244
01:08:29,460 --> 01:08:33,310
going to blow the
original D's space bound

1245
01:08:33,310 --> 01:08:34,660
and exceed the bound.

1246
01:08:34,660 --> 01:08:39,920
And so D is going to
reject upright in step one

1247
01:08:39,920 --> 01:08:42,350
when it tries to get
an input of itself.

1248
01:08:46,109 --> 01:08:48,130
It's very clear what's
going to happen.

1249
01:08:48,130 --> 01:08:50,430
It's just going to
reject, because of--

1250
01:08:50,430 --> 01:08:53,220
for this, reject in particular.

1251
01:08:53,220 --> 01:08:57,020
And notice this, you know, yes.

1252
01:08:57,020 --> 01:09:00,890
You know, OK, let me
not try to confuse it.

1253
01:09:00,890 --> 01:09:04,800
OK, so that's all I
want to say about this.

1254
01:09:04,800 --> 01:09:07,640
Let's now move in our
remaining 7 minutes

1255
01:09:07,640 --> 01:09:11,710
to the time hierarchy
theorem, which

1256
01:09:11,710 --> 01:09:13,930
is very has the same proof.

1257
01:09:13,930 --> 01:09:16,772
But some of the technical
details are slightly different.

1258
01:09:21,620 --> 01:09:24,350
So now, if I give
you a time bound,

1259
01:09:24,350 --> 01:09:26,810
again, we are going to have
to face with the same notion,

1260
01:09:26,810 --> 01:09:28,268
that you have to
be able to compute

1261
01:09:28,268 --> 01:09:31,208
f within x amount of time.

1262
01:09:31,208 --> 01:09:32,750
So it has to be a
time constructable.

1263
01:09:32,750 --> 01:09:36,149
I'm not going to define that.

1264
01:09:36,149 --> 01:09:40,590
So there's a language A which
requires that much time.

1265
01:09:40,590 --> 01:09:42,578
So it has to be decided
within that much time.

1266
01:09:42,578 --> 01:09:44,120
But there's a slight
difference here.

1267
01:09:44,120 --> 01:09:47,149
And this is an artifact of
the proof of the theorem,

1268
01:09:47,149 --> 01:09:51,319
not because it's an absolute
truth, as far as we know.

1269
01:09:51,319 --> 01:09:54,380
It's not that it's not
decidable in little o of f of n.

1270
01:09:54,380 --> 01:09:57,860
You actually, you can only
prove something slightly weaker

1271
01:09:57,860 --> 01:09:59,630
when you have one
tape Turing machines.

1272
01:09:59,630 --> 01:10:03,500
That it's decidable
in little o over--

1273
01:10:03,500 --> 01:10:09,890
there's a slight gap
in what you can prove.

1274
01:10:09,890 --> 01:10:12,470
So it's not only that
you can't prove--

1275
01:10:12,470 --> 01:10:13,670
it requires little o.

1276
01:10:13,670 --> 01:10:15,240
But little o of--

1277
01:10:15,240 --> 01:10:18,710
little o of f of
n over log f of n

1278
01:10:18,710 --> 01:10:23,070
is what you can prove that you
get from this time hierarchy

1279
01:10:23,070 --> 01:10:23,570
theorem.

1280
01:10:23,570 --> 01:10:25,730
But let's not get caught
up on that for now.

1281
01:10:31,390 --> 01:10:34,060
So the proof outline is the
same outline as we had before.

1282
01:10:36,670 --> 01:10:40,280
We're going to give a D that
runs in order f of n time.

1283
01:10:40,280 --> 01:10:46,360
So it ensures that the language
is in that time complexity

1284
01:10:46,360 --> 01:10:48,040
class time f of n.

1285
01:10:48,040 --> 01:10:50,770
And it makes sure it's different
from every machine that

1286
01:10:50,770 --> 01:10:52,600
runs faster.

1287
01:10:52,600 --> 01:10:55,420
By some significant--
by a log factor faster.

1288
01:10:59,600 --> 01:11:06,570
And so, why don't I
show how that goes.

1289
01:11:06,570 --> 01:11:10,280
The proof is, in some ways,
almost exactly the same.

1290
01:11:13,050 --> 01:11:16,410
I'm going to give a D, which
runs in this much time,

1291
01:11:16,410 --> 01:11:19,710
and it shows it's
different from every M that

1292
01:11:19,710 --> 01:11:24,880
runs in a lot less time.

1293
01:11:24,880 --> 01:11:29,082
Here is the algorithm for
D. Now, it computes f of n.

1294
01:11:29,082 --> 01:11:31,290
But it does something a
little different with f of n.

1295
01:11:31,290 --> 01:11:34,890
Remember, in the space
hierarchy theorem,

1296
01:11:34,890 --> 01:11:38,970
we marked off f of n space.

1297
01:11:38,970 --> 01:11:41,850
Now, this f of n is going to be
used for a different purpose.

1298
01:11:41,850 --> 01:11:44,410
It's going to be a clock.

1299
01:11:44,410 --> 01:11:48,606
And you have to shut M down
if it runs for more than f

1300
01:11:48,606 --> 01:11:50,020
of n steps.

1301
01:11:50,020 --> 01:11:51,895
Not if it uses more
than f of n space.

1302
01:11:54,760 --> 01:11:59,290
Because we're only interested in
M's that use significantly less

1303
01:11:59,290 --> 01:12:01,130
than f of n time.

1304
01:12:01,130 --> 01:12:06,430
So we're going to run M for
f for some number of steps.

1305
01:12:06,430 --> 01:12:08,920
Whatever M says, we're
going to do the opposite.

1306
01:12:08,920 --> 01:12:11,590
And only if we can actually
finish that simulation,

1307
01:12:11,590 --> 01:12:13,390
will we be able to
be sure that we're

1308
01:12:13,390 --> 01:12:16,770
different from what M is doing.

1309
01:12:16,770 --> 01:12:18,270
So this is the whole
algorithm here.

1310
01:12:18,270 --> 01:12:21,460
We don't have to do any
further modifications.

1311
01:12:21,460 --> 01:12:25,080
And where is that log
n factor coming from?

1312
01:12:25,080 --> 01:12:26,790
It's actually coming
from a funny place.

1313
01:12:30,140 --> 01:12:34,190
And you have to get into a
little bit of the guts of this.

1314
01:12:34,190 --> 01:12:39,360
When you're simulating M on
w, remember that M itself

1315
01:12:39,360 --> 01:12:41,798
was described by w.

1316
01:12:41,798 --> 01:12:43,340
So you're going to
have to write down

1317
01:12:43,340 --> 01:12:50,200
a copy of M, which is just
as described by W. And then

1318
01:12:50,200 --> 01:12:51,700
so you're going
to-- and then you're

1319
01:12:51,700 --> 01:12:55,370
going to have the tape
that M is working on,

1320
01:12:55,370 --> 01:12:57,460
which is starting
out with w on it.

1321
01:13:00,090 --> 01:13:03,930
And you have to be, now you
have to be a little careful

1322
01:13:03,930 --> 01:13:05,080
how you manage that.

1323
01:13:05,080 --> 01:13:08,190
Because if your
description of M is just

1324
01:13:08,190 --> 01:13:13,580
sitting at the beginning of the
tape, as you're simulating M,

1325
01:13:13,580 --> 01:13:16,940
every time you do one step
in modifying the tape,

1326
01:13:16,940 --> 01:13:19,820
you don't want to
have to go back

1327
01:13:19,820 --> 01:13:23,980
to the beginning of the tape
to look up the next step of M.

1328
01:13:23,980 --> 01:13:27,430
So you actually have to
carry M along with you

1329
01:13:27,430 --> 01:13:29,930
as you're doing the simulation.

1330
01:13:29,930 --> 01:13:34,090
And you can do that by expanding
the tape alphabet of the tape

1331
01:13:34,090 --> 01:13:39,290
so that you can effectively
have two symbols on one cell.

1332
01:13:39,290 --> 01:13:41,560
One is going to be
for describing M,

1333
01:13:41,560 --> 01:13:45,910
and the other one is going to
be for just for the simulation

1334
01:13:45,910 --> 01:13:46,780
tape.

1335
01:13:46,780 --> 01:13:49,450
And you'll be carrying
M along with you

1336
01:13:49,450 --> 01:13:51,550
wherever your head
is, so you don't have

1337
01:13:51,550 --> 01:13:57,190
to go very far to look up M.
And so that's all possible,

1338
01:13:57,190 --> 01:13:59,890
because that's going to add only
a constant factor, because M

1339
01:13:59,890 --> 01:14:02,470
is fixed in size,
doesn't depend on--

1340
01:14:07,331 --> 01:14:10,370
for large inputs
to M, M is fixed.

1341
01:14:10,370 --> 01:14:13,510
But the tricky thing
here is the counter,

1342
01:14:13,510 --> 01:14:15,310
to make sure we're not
using too much time.

1343
01:14:18,250 --> 01:14:21,010
The counter has size log
f of n, because that's

1344
01:14:21,010 --> 01:14:25,180
how big it has to count up to
so you can shut it down if it's

1345
01:14:25,180 --> 01:14:28,540
going to exceed f of n steps.

1346
01:14:28,540 --> 01:14:32,230
And let's see,
you'll have to run

1347
01:14:32,230 --> 01:14:33,850
for a certain amount of time.

1348
01:14:33,850 --> 01:14:38,380
And keeping the
counter nearby has--

1349
01:14:38,380 --> 01:14:40,660
the counter now, it
can be pretty big.

1350
01:14:40,660 --> 01:14:46,570
And so that's going to cost you
a log factor of simulation cost

1351
01:14:46,570 --> 01:14:50,390
to move that counter
around all the time.

1352
01:14:50,390 --> 01:14:56,980
And so that's why you have to
run for only a log factor less,

1353
01:14:56,980 --> 01:15:00,610
so that you can actually
finish within f of n time,

1354
01:15:00,610 --> 01:15:02,890
as you're required to do.

1355
01:15:02,890 --> 01:15:04,720
I realize that that's
a mouthful there.

1356
01:15:04,720 --> 01:15:06,850
And you may not have
all understood that.

1357
01:15:06,850 --> 01:15:07,782
It doesn't matter.

1358
01:15:07,782 --> 01:15:08,740
It's not that critical.

1359
01:15:08,740 --> 01:15:10,448
I think what I'm really
more concerned is

1360
01:15:10,448 --> 01:15:15,430
you understand the main idea
of the hierarchy theorem.

1361
01:15:15,430 --> 01:15:21,430
Some of these implementation
details, if you don't get them,

1362
01:15:21,430 --> 01:15:22,810
I wouldn't worry about it.

1363
01:15:22,810 --> 01:15:25,300
I feel I have to include
them for completeness sake

1364
01:15:25,300 --> 01:15:27,080
and to be honest with
you about the proof.

1365
01:15:27,080 --> 01:15:29,470
But if you didn't follow
everything, that's OK.

1366
01:15:29,470 --> 01:15:34,540
I do want to understand the main
idea, though, of the algorithm,

1367
01:15:34,540 --> 01:15:37,660
making sure that what it's
doing is different from what

1368
01:15:37,660 --> 01:15:41,380
every machine is doing if that
machine runs in little o of f

1369
01:15:41,380 --> 01:15:45,970
of n space or a small amount
of time, little o of f of n

1370
01:15:45,970 --> 01:15:48,520
over log f of n time.

1371
01:15:48,520 --> 01:15:52,400
And I think we're
going to end here.

1372
01:15:52,400 --> 01:15:54,580
So we're pretty
much out of time.

1373
01:15:54,580 --> 01:15:58,570
I'm going to stick
around for a little bit,

1374
01:15:58,570 --> 01:16:00,460
in case there's
any questions here.

1375
01:16:00,460 --> 01:16:03,700
Oh, there's one last
check-in though.

1376
01:16:03,700 --> 01:16:04,510
Let's look at this.

1377
01:16:04,510 --> 01:16:06,610
This is kind of an
interesting sort of follow on

1378
01:16:06,610 --> 01:16:09,550
to the hierarchy theorem.

1379
01:16:09,550 --> 01:16:12,400
If you look at the two
questions, does L equal P,

1380
01:16:12,400 --> 01:16:15,380
and does P equal P space?

1381
01:16:15,380 --> 01:16:19,090
These are both
unsolved problems.

1382
01:16:19,090 --> 01:16:21,070
What, if anything, does
the hierarchy theorem

1383
01:16:21,070 --> 01:16:24,400
tell us about those questions?

1384
01:16:24,400 --> 01:16:27,100
And it's kind of interesting,
that there are actually-- well,

1385
01:16:27,100 --> 01:16:32,650
I'll leave it to you to tell
me if you can see what it

1386
01:16:32,650 --> 01:16:34,390
might actually be telling you.

1387
01:16:34,390 --> 01:16:35,620
Closing.

1388
01:16:35,620 --> 01:16:36,640
Get your answer in.

1389
01:16:39,800 --> 01:16:42,890
OK, 1, 2, 3.

1390
01:16:42,890 --> 01:16:45,780
I feel like I'm running
an auction house here.

1391
01:16:45,780 --> 01:16:46,905
And I should have a gavel.

1392
01:16:53,910 --> 01:16:57,390
Yes, in fact, we know
that these are separated.

1393
01:16:57,390 --> 01:16:59,130
So it's not-- even
though we don't

1394
01:16:59,130 --> 01:17:01,560
know if L equals P,
or P equal P space,

1395
01:17:01,560 --> 01:17:03,330
they can't both be equal.

1396
01:17:03,330 --> 01:17:06,520
Because then L
would equal P space,

1397
01:17:06,520 --> 01:17:08,970
and we know that's false.

1398
01:17:08,970 --> 01:17:11,920
So at least one of
these has the answer no.

1399
01:17:11,920 --> 01:17:15,700
So with that, let's
wrap up today's lecture.

1400
01:17:15,700 --> 01:17:17,770
Now we prove these
hierarchy theorems.

1401
01:17:17,770 --> 01:17:21,260
And why don't we just--

1402
01:17:21,260 --> 01:17:25,630
I'm going to shut us down here.

1403
01:17:25,630 --> 01:17:29,020
But before-- well,
I mean, we're over,

1404
01:17:29,020 --> 01:17:30,988
so you can feel free to go.

1405
01:17:30,988 --> 01:17:33,280
But I'll stick around in case
anybody has any questions

1406
01:17:33,280 --> 01:17:34,900
for a few minutes anyway.

1407
01:17:34,900 --> 01:17:38,460
And then we'll call it a day.

1408
01:17:38,460 --> 01:17:41,490
Since we just showed space N
is a proper subset of space N

1409
01:17:41,490 --> 01:17:44,610
to the K for any K,
why can't we also say

1410
01:17:44,610 --> 01:17:46,470
space N is a proper
subset of P space?

1411
01:17:46,470 --> 01:17:49,990
Yes, space N is a proper
subset of P space.

1412
01:17:49,990 --> 01:17:50,490
Yeah.

1413
01:17:50,490 --> 01:17:52,980
So somebody just
asked, we just showed

1414
01:17:52,980 --> 01:17:58,350
that space N is a proper subset
of space N to the K. Does

1415
01:17:58,350 --> 01:18:01,260
that also say that space N is
a proper subset of P space?

1416
01:18:01,260 --> 01:18:02,010
Definitely.

1417
01:18:06,400 --> 01:18:10,450
Space N to the K is a proper
subset of space N to the K

1418
01:18:10,450 --> 01:18:13,780
plus 1, which is a
subset of P space.

1419
01:18:13,780 --> 01:18:17,620
So any fixed polynomial is
going to be a subset of P space,

1420
01:18:17,620 --> 01:18:20,020
because P space includes
all the polynomials.

1421
01:18:20,020 --> 01:18:23,350
Which of the two
unsolved problems--

1422
01:18:23,350 --> 01:18:28,590
whoops-- do I think is more
like likely to be true?

1423
01:18:28,590 --> 01:18:32,950
Well, I think most--

1424
01:18:32,950 --> 01:18:35,440
I mean, I would bet that
both of these are not equal.

1425
01:18:35,440 --> 01:18:37,240
So both of these have answer no.

1426
01:18:40,060 --> 01:18:44,950
It would be weird, you know,
I mean, you think L equals P?

1427
01:18:44,950 --> 01:18:46,590
That anything can do
in polynomial time

1428
01:18:46,590 --> 01:18:47,590
you can do in log space?

1429
01:18:47,590 --> 01:18:49,810
Log space is incredibly weak.

1430
01:18:49,810 --> 01:18:53,200
And P space is
incredibly strong.

1431
01:18:53,200 --> 01:18:56,130
I would be shocked if
either of these were equal.

1432
01:18:56,130 --> 01:18:58,520
So we just-- the
problem is that we

1433
01:18:58,520 --> 01:19:05,870
don't have a method for
proving problems are actually,

1434
01:19:05,870 --> 01:19:08,120
have high complexity
of any sort.

1435
01:19:08,120 --> 01:19:10,220
We don't know how to
show things outside of L.

1436
01:19:10,220 --> 01:19:14,000
Don't know how to show
things outside of P. Except

1437
01:19:14,000 --> 01:19:15,500
by using the hierarchy theorem.

1438
01:19:15,500 --> 01:19:17,750
Diagonalization
is the only method

1439
01:19:17,750 --> 01:19:20,720
that we have for showing
things are outside of classes.

1440
01:19:20,720 --> 01:19:22,830
And there's reason
to believe, as well.

1441
01:19:22,830 --> 01:19:25,700
This we'll get to, I think,
next lecture, in fact.

1442
01:19:25,700 --> 01:19:29,360
There's kind of reasons to
believe that the hierarchy

1443
01:19:29,360 --> 01:19:32,120
theorem type argument,
which is diagonalization

1444
01:19:32,120 --> 01:19:36,780
is not going to answer
those kinds of questions.

1445
01:19:36,780 --> 01:19:38,240
So we need a different method.

1446
01:19:38,240 --> 01:19:40,430
And diagonalization
is all we got.

1447
01:19:43,430 --> 01:19:44,553
Good question, though.

1448
01:19:44,553 --> 01:19:46,220
If I didn't get to
answer your question,

1449
01:19:46,220 --> 01:19:47,900
you have a question
for me, ask it again,

1450
01:19:47,900 --> 01:19:48,900
because it's got buried.

1451
01:19:51,410 --> 01:19:55,010
So it means we are very far
from disproving P versus NP,

1452
01:19:55,010 --> 01:19:58,010
is that right?

1453
01:19:58,010 --> 01:19:59,100
It could happen tomorrow.

1454
01:20:01,860 --> 01:20:04,440
How can you tell?

1455
01:20:04,440 --> 01:20:08,010
It doesn't-- it seems clear
that the present state

1456
01:20:08,010 --> 01:20:13,920
of mathematics, as of right
now, is we don't have a clue how

1457
01:20:13,920 --> 01:20:15,963
to answer those
kinds of questions.

1458
01:20:15,963 --> 01:20:18,255
And it's not obvious that
we've even made any progress.

1459
01:20:21,010 --> 01:20:24,240
But you know, that's
the nature of the game.

1460
01:20:24,240 --> 01:20:26,100
That's the nature of the beast.

1461
01:20:26,100 --> 01:20:29,040
Somebody gets a good idea, and
all of a sudden lots of things

1462
01:20:29,040 --> 01:20:30,060
can change.

1463
01:20:30,060 --> 01:20:31,800
And that can happen
at any point.

1464
01:20:31,800 --> 01:20:33,960
Maybe one of you guys.

1465
01:20:33,960 --> 01:20:37,170
When would these results first--

1466
01:20:37,170 --> 01:20:38,010
the stuff.

1467
01:20:38,010 --> 01:20:38,760
OK.

1468
01:20:38,760 --> 01:20:40,770
The hierarchy theorem is old.

1469
01:20:40,770 --> 01:20:45,450
That goes back to the very--
when time classes were first

1470
01:20:45,450 --> 01:20:48,420
defined, I think it's
one of the first results

1471
01:20:48,420 --> 01:20:50,670
to show the hierarchy.

1472
01:20:50,670 --> 01:20:54,765
And that's late '60s.

1473
01:20:58,520 --> 01:21:03,890
The NL equal coNL, I think I
mentioned, was like mid-1980s.

1474
01:21:03,890 --> 01:21:05,800
Much later.

1475
01:21:05,800 --> 01:21:07,780
I mean, from your
points of view,

1476
01:21:07,780 --> 01:21:14,290
it was back in the
cave age either way.

1477
01:21:14,290 --> 01:21:17,080
But yeah, but the
hierarchy theorem,

1478
01:21:17,080 --> 01:21:21,520
that actually predates
my coming into the field.

1479
01:21:21,520 --> 01:21:24,280
But the NL equal coNL,
that was something

1480
01:21:24,280 --> 01:21:28,210
that I personally experienced
how surprised people were.

1481
01:21:31,220 --> 01:21:35,240
I think I'm going to send
you off, all off on your way.

1482
01:21:35,240 --> 01:21:36,590
But good having you here.

1483
01:21:36,590 --> 01:21:38,840
And have a good
weekend, everybody.

1484
01:21:38,840 --> 01:21:43,420
And I will see you on Tuesday.

1485
01:21:43,420 --> 01:21:44,790
Bye-bye.